import { Logger } from '../utils/Logger';
import { textToSpeech } from '@kit.CoreSpeechKit';
import { systemDateTime } from '@kit.BasicServicesKit';

/**
 * TTSæ’­æ”¾çŠ¶æ€æšä¸¾
 */
export enum TTSState {
  IDLE = 'idle',
  INITIALIZING = 'initializing', 
  PLAYING = 'playing',
  PAUSED = 'paused',
  STOPPED = 'stopped',
  ERROR = 'error'
}

/**
 * TTSé…ç½®æ¥å£
 */
export interface TTSConfig {
  language?: string;    // è¯­è¨€
  voice?: string;       // å£°éŸ³ç±»å‹
  rate?: number;        // è¯­é€Ÿ (0.1 - 3.0)
  pitch?: number;       // éŸ³è°ƒ (0.5 - 2.0) 
  volume?: number;      // éŸ³é‡ (0.0 - 1.0)
}

/**
 * TTSäº‹ä»¶å›è°ƒæ¥å£
 */
export interface TTSCallbacks {
  onStart?: () => void;
  onComplete?: () => void;
  onError?: (error: Error) => void;
  onPause?: () => void;
  onResume?: () => void;
  onStop?: () => void;
}

/**
 * TTSæœåŠ¡çŠ¶æ€æ¥å£
 */
export interface TTSServiceStatus {
  isReady: boolean;
  currentState: TTSState;
  hasActiveRequest: boolean;
  engineVersion?: string;
  config: TTSConfig;
}

/**
 * æ–‡å­—è½¬è¯­éŸ³æœåŠ¡ç±» - åä¸ºTTS APIå®ç°
 */
export class TTSService {
  private static instance: TTSService | null = null;
  private currentState: TTSState = TTSState.IDLE;
  private currentText: string = '';
  private callbacks: TTSCallbacks = {};
  private config: TTSConfig = {
    language: 'zh-CN',
    voice: 'zh-CN-XiaoxiaoNeural',
    rate: 1.0,
    pitch: 1.0,
    volume: 1.0
  };
  private ttsEngine: textToSpeech.TextToSpeechEngine | null = null;
  private currentRequestId: string = '';
  private isEngineReady: boolean = false;
  private maxRetries: number = 3;
  private retryDelay: number = 1000;
  private callbacksMap: Map<string, TTSCallbacks> = new Map();
  private requestCounter: number = 0;

  private constructor() {
    Logger.info('TTSService', 'åˆ›å»ºTTSæœåŠ¡å®ä¾‹');
  }

  /**
   * è·å–TTSæœåŠ¡å•ä¾‹
   */
  static getInstance(): TTSService {
    if (TTSService.instance === null) {
      TTSService.instance = new TTSService();
    }
    return TTSService.instance;
  }

  /**
   * é™æ€æ–¹æ³•ï¼šè¿‡æ»¤æ–‡æœ¬ï¼Œç§»é™¤ä¸é€‚åˆè¯­éŸ³æœ—è¯»çš„å­—ç¬¦
   * å¯ä»¥å•ç‹¬ä½¿ç”¨è€Œä¸éœ€è¦åˆ›å»ºTTSServiceå®ä¾‹
   */
  static filterTextForSpeech(text: string): string {
    if (!text) {
      return '';
    }

    return text
      // ç§»é™¤è¡¨æƒ…ç¬¦å·
      .replace(/[\u{1F600}-\u{1F64F}]/gu, '')  // è¡¨æƒ…ç¬¦å· ğŸ˜€-ğŸ™
      .replace(/[\u{1F300}-\u{1F5FF}]/gu, '')  // æ‚é¡¹ç¬¦å·å’Œè±¡å½¢æ–‡å­— ğŸŒ€-ğŸ—¿
      .replace(/[\u{1F680}-\u{1F6FF}]/gu, '')  // äº¤é€šå’Œåœ°å›¾ç¬¦å· ğŸš€-ğŸ›¿
      .replace(/[\u{1F700}-\u{1F77F}]/gu, '')  // ç‚¼é‡‘æœ¯ç¬¦å·
      .replace(/[\u{1F780}-\u{1F7FF}]/gu, '')  // å‡ ä½•å½¢çŠ¶æ‰©å±•
      .replace(/[\u{1F800}-\u{1F8FF}]/gu, '')  // è¡¥å……ç®­å¤´-C
      .replace(/[\u{1F900}-\u{1F9FF}]/gu, '')  // è¡¥å……ç¬¦å·å’Œè±¡å½¢æ–‡å­— ğŸ¤€-ğŸ§¿
      .replace(/[\u{1FA00}-\u{1FA6F}]/gu, '')  // æ‰©å±•A ğŸ¨€-ğŸ©¯
      .replace(/[\u{1FA70}-\u{1FAFF}]/gu, '')  // æ‰©å±•B ğŸ©°-ğŸ«¿
      .replace(/[\u{2600}-\u{26FF}]/gu, '')    // æ‚é¡¹ç¬¦å· â˜€-â›¿
      .replace(/[\u{2700}-\u{27BF}]/gu, '')    // è£…é¥°ç¬¦å· âœ€-â¿
      .replace(/[\u{FE00}-\u{FE0F}]/gu, '')    // å˜ä½“é€‰æ‹©å™¨
      .replace(/[\u{1F1E0}-\u{1F1FF}]/gu, '')  // æ——å¸œç¬¦å·

      // ç§»é™¤ Markdown æ ¼å¼å­—ç¬¦ï¼Œä¿ç•™å†…å®¹
      .replace(/#{1,6}\s*/g, '')             // ç§»é™¤æ ‡é¢˜ç¬¦å· # ## ###
      .replace(/\*{1,3}(.*?)\*{1,3}/g, '$1') // ç§»é™¤ç²—ä½“æ–œä½“æ ‡è®°ï¼Œä¿ç•™å†…å®¹ *text* **text** ***text***
      .replace(/_{1,3}(.*?)_{1,3}/g, '$1')   // ç§»é™¤ä¸‹åˆ’çº¿æ ‡è®°ï¼Œä¿ç•™å†…å®¹ _text_ __text__ ___text___
      .replace(/`{1,3}(.*?)`{1,3}/g, '$1')   // ç§»é™¤ä»£ç å—æ ‡è®°ï¼Œä¿ç•™ä»£ç å†…å®¹ `code` ```code```
      .replace(/\[(.*?)\]\(.*?\)/g, '$1')    // ç§»é™¤é“¾æ¥æ ¼å¼ï¼Œä¿ç•™æ–‡å­— [text](url)
      .replace(/!\[(.*?)\]\(.*?\)/g, '$1')   // ç§»é™¤å›¾ç‰‡æ ¼å¼ï¼Œä¿ç•™altæ–‡å­— ![alt](url)

      // ç§»é™¤è¡¨æ ¼å’Œåˆ†å‰²çº¿ç¬¦å·
      .replace(/\|/g, '')                    // ç§»é™¤è¡¨æ ¼åˆ†éš”ç¬¦ |
      .replace(/[-]{3,}/g, '')               // ç§»é™¤åˆ†å‰²çº¿ ---
      .replace(/[=]{3,}/g, '')               // ç§»é™¤åˆ†å‰²çº¿ ===
      .replace(/>/g, '')                     // ç§»é™¤å¼•ç”¨ç¬¦å· >
      .replace(/~/g, '')                     // ç§»é™¤åˆ é™¤çº¿ç¬¦å· ~

      // ç§»é™¤ç¼–ç¨‹ç‰¹æ®Šç¬¦å·ï¼Œä¿ç•™åŸºæœ¬æ ‡ç‚¹ç¬¦å·
      .replace(/[@#$%^&+={}\\<>]/g, '')      // ç§»é™¤ç¼–ç¨‹ç¬¦å·ï¼Œä¿ç•™æ‹¬å·()[]ã€é€—å·,ã€å¥å·.ã€é—®å·?ã€æ„Ÿå¹å·!ã€åˆ†å·;ã€å†’å·:ã€å¼•å·"ã€æ˜Ÿå·*
      .replace(/Â·/g, '')                     // ç§»é™¤ä¸­æ–‡é—´éš”å·

      // å¤„ç†ç©ºæ ¼å’Œæ ¼å¼
      .replace(/\s+/g, ' ')                  // å¤šä¸ªç©ºæ ¼åˆå¹¶ä¸ºä¸€ä¸ª
      .replace(/^\s+|\s+$/g, '')             // å»é™¤é¦–å°¾ç©ºæ ¼
      .trim();
  }

  /**
   * åˆå§‹åŒ–TTSå¼•æ“
   */
  async initialize(callbacks?: TTSCallbacks): Promise<boolean> {
    const effectiveCallbacks: TTSCallbacks = callbacks || {};
    let requestId: string = '';

    try {
      this.currentState = TTSState.INITIALIZING;
      Logger.info('TTSService', 'å¼€å§‹åˆå§‹åŒ–åä¸ºTTSå¼•æ“');

      // åˆå§‹åŒ–å‰æ¸…ç†æ®‹ç•™çŠ¶æ€
      this.callbacksMap.clear();
      this.currentRequestId = '';
      this.callbacks = {};

      // åˆ›å»ºTTSå¼•æ“é…ç½®
      const engineConfig: textToSpeech.CreateEngineParams = {
        language: this.config.language || 'zh-CN',
        person: 0, // 0ä¸ºè†å°çŠå¥³å£°éŸ³è‰²
        online: 1  // ç¦»çº¿æ¨¡å¼ï¼Œç›®å‰ä»…æ”¯æŒç¦»çº¿1
      };

      // åˆ›å»ºTTSå¼•æ“
      this.ttsEngine = await textToSpeech.createEngine(engineConfig);
      
      if (!this.ttsEngine) {
        throw new Error('TTSå¼•æ“åˆ›å»ºå¤±è´¥');
      }

      // è®¾ç½®TTSäº‹ä»¶ç›‘å¬å™¨
      this.setupTTSListeners();

      this.isEngineReady = true;
      this.currentState = TTSState.IDLE;
      Logger.info('TTSService', 'åä¸ºTTSå¼•æ“åˆå§‹åŒ–æˆåŠŸ');
      return true;

    } catch (error) {
      this.currentState = TTSState.ERROR;
      this.isEngineReady = false;
      const err = error as Error;
      Logger.error('TTSService', `åä¸ºTTSå¼•æ“åˆå§‹åŒ–å¤±è´¥: ${err.message}`);
      return false;
    }
  }

  /**
   * è®¾ç½®TTSäº‹ä»¶ç›‘å¬å™¨
   */
  private setupTTSListeners(): void {
    if (!this.ttsEngine) {
      return;
    }

    this.ttsEngine.setListener({
      // å¼€å§‹æ’­æŠ¥å›è°ƒ
      onStart: (requestId: string, response: textToSpeech.StartResponse) => {
        const callbacks = this.callbacksMap.get(requestId);
        const isCurrent = requestId === this.currentRequestId;

        Logger.info('TTSService', `TTSå¼€å§‹æ’­æ”¾ requestId: ${requestId}`);

        if (isCurrent) {
          this.currentState = TTSState.PLAYING;
        } else {
          Logger.debug('TTSService', `æ”¶åˆ°éå½“å‰è¯·æ±‚çš„æ’­æ”¾å¼€å§‹å›è°ƒ requestId: ${requestId}, å½“å‰è¯·æ±‚: ${this.currentRequestId || 'æ— '}`);
        }

        callbacks?.onStart?.();
      },

      // åˆæˆå®ŒæˆåŠæ’­æŠ¥å®Œæˆå›è°ƒ
      onComplete: (requestId: string, response: textToSpeech.CompleteResponse) => {
        const callbacks = this.callbacksMap.get(requestId);
        const isCurrent = requestId === this.currentRequestId;

        Logger.info('TTSService', `TTSæ’­æ”¾å®Œæˆ requestId: ${requestId}`);

        if (isCurrent) {
          this.currentState = TTSState.IDLE;
          this.currentText = '';
          this.currentRequestId = '';
          this.callbacks = {};
        } else {
          Logger.debug('TTSService', `æ’­æ”¾å®Œæˆå›è°ƒæ¥è‡ªéå½“å‰è¯·æ±‚ requestId: ${requestId}, å½“å‰è¯·æ±‚: ${this.currentRequestId || 'æ— '}`);
        }

        callbacks?.onComplete?.();
        this.cleanupRequestResources(requestId);
      },

      // åœæ­¢æ’­æŠ¥å›è°ƒ
      onStop: (requestId: string, response: textToSpeech.StopResponse) => {
        const callbacks = this.callbacksMap.get(requestId);
        const isCurrent = requestId === this.currentRequestId;

        Logger.info('TTSService', `TTSæ’­æ”¾åœæ­¢ requestId: ${requestId}`);

        if (isCurrent) {
          this.currentState = TTSState.STOPPED;
          this.currentText = '';
          this.currentRequestId = '';
          this.callbacks = {};
        } else {
          Logger.debug('TTSService', `åœæ­¢å›è°ƒæ¥è‡ªéå½“å‰è¯·æ±‚ requestId: ${requestId}, å½“å‰è¯·æ±‚: ${this.currentRequestId || 'æ— '}`);
        }

        callbacks?.onStop?.();
        this.cleanupRequestResources(requestId);
      },

      // è¿”å›éŸ³é¢‘æµï¼ˆå¯é€‰å¤„ç†ï¼‰
      onData: (requestId: string, audio: ArrayBuffer, response: textToSpeech.SynthesisResponse) => {
        Logger.debug('TTSService', `TTSéŸ³é¢‘æ•°æ® requestId: ${requestId} audioSize: ${audio.byteLength}`);
      },

      // é”™è¯¯å›è°ƒ
      onError: (requestId: string, errorCode: number, errorMessage: string) => {
        const callbacks = this.callbacksMap.get(requestId);
        const isCurrent = requestId === this.currentRequestId;

        Logger.error('TTSService', `TTSæ’­æ”¾é”™è¯¯ requestId: ${requestId} code: ${errorCode} message: ${errorMessage}`);

        if (isCurrent) {
          this.currentState = TTSState.ERROR;
          this.currentText = '';
          this.currentRequestId = '';
          this.callbacks = {};
        }

        const error = new Error(`TTSæ’­æ”¾é”™è¯¯: ${errorMessage} (Code: ${errorCode})`);
        callbacks?.onError?.(error);
        this.cleanupRequestResources(requestId);
      }
    });
  }

  /**
   * æ’­æ”¾æ–‡æœ¬ï¼ˆå¸¦é‡è¯•é€»è¾‘ï¼‰
   */
  async speak(text: string, callbacks?: TTSCallbacks): Promise<boolean> {
    return this.speakWithRetry(text, callbacks, 0);
  }

  /**
   * å®ä¾‹æ–¹æ³•ï¼šè¿‡æ»¤æ–‡æœ¬ï¼Œç§»é™¤ä¸é€‚åˆè¯­éŸ³æœ—è¯»çš„å­—ç¬¦
   */
  private filterTextForSpeech(text: string): string {
    return TTSService.filterTextForSpeech(text);
  }

  /**
   * æ’­æ”¾æ–‡æœ¬çš„å†…éƒ¨å®ç°ï¼ˆå¸¦é‡è¯•é€»è¾‘ï¼‰
   */
  private async speakWithRetry(text: string, callbacks?: TTSCallbacks, retryCount: number = 0): Promise<boolean> {
    if (!text || text.trim().length === 0) {
      Logger.warn('TTSService', 'æ’­æ”¾æ–‡æœ¬ä¸ºç©º');
      return false;
    }

    let speakRequestId: string = '';

    // è¿‡æ»¤æ–‡æœ¬ï¼Œç§»é™¤ä¸é€‚åˆè¯­éŸ³æœ—è¯»çš„å­—ç¬¦
    const filteredText = this.filterTextForSpeech(text);
    if (!filteredText || filteredText.trim().length === 0) {
      Logger.warn('TTSService', 'è¿‡æ»¤åçš„æ–‡æœ¬ä¸ºç©ºï¼Œè·³è¿‡æœ—è¯»');
      return false;
    }

    // å¦‚æœå¼•æ“æœªå‡†å¤‡å°±ç»ªï¼Œå°è¯•åˆå§‹åŒ–
    if (!this.isEngineReady || !this.ttsEngine) {
      Logger.warn('TTSService', 'TTSå¼•æ“æœªå‡†å¤‡å°±ç»ªï¼Œå°è¯•é‡æ–°åˆå§‹åŒ–');
      const initSuccess = await this.initialize();
      if (!initSuccess && retryCount < this.maxRetries) {
        Logger.info('TTSService', `TTSåˆå§‹åŒ–å¤±è´¥ï¼Œç¬¬ ${retryCount + 1} æ¬¡é‡è¯•`);
        await this.delay(this.retryDelay);
        return this.speakWithRetry(text, callbacks, retryCount + 1);
      } else if (!initSuccess) {
        Logger.error('TTSService', 'è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼ŒTTSåˆå§‹åŒ–å¤±è´¥');
        return false;
      }
    }

    // å¦‚æœæ­£åœ¨æ’­æ”¾å…¶ä»–æ–‡æœ¬ï¼Œå…ˆå¼ºåˆ¶åœæ­¢
    if (this.isPlaying() || this.isPaused()) {
      Logger.info('TTSService', `æ£€æµ‹åˆ°æ­£åœ¨æ’­æ”¾/æš‚åœçš„éŸ³é¢‘ï¼Œæ‰§è¡Œå¼ºåˆ¶åœæ­¢æ“ä½œ (çŠ¶æ€: ${this.currentState})`);
      await this.forceStop();
      
      // ç­‰å¾…çŠ¶æ€æ›´æ–°ï¼Œè®¾ç½®è¾ƒçŸ­çš„è¶…æ—¶æ—¶é—´é¿å…ç”¨æˆ·ç­‰å¾…è¿‡ä¹…
      const stopped = await this.waitForState([TTSState.IDLE, TTSState.STOPPED], 500);
      if (!stopped) {
        Logger.warn('TTSService', 'ç­‰å¾…éŸ³é¢‘åœæ­¢è¶…æ—¶ï¼Œå¼ºåˆ¶é‡ç½®çŠ¶æ€');
        // å¼ºåˆ¶é‡ç½®çŠ¶æ€
        this.currentState = TTSState.IDLE;
        this.currentText = '';
        this.currentRequestId = '';
      }
    }

    try {
      // è®¾ç½®å›è°ƒå‡½æ•°
      this.callbacks = callbacks || {};

      this.currentText = filteredText;
      Logger.info('TTSService', `å¼€å§‹æ’­æ”¾è¿‡æ»¤åæ–‡æœ¬: ${filteredText.substring(0, 50)}${filteredText.length > 50 ? '...' : ''} (é‡è¯•æ¬¡æ•°: ${retryCount})`);
      Logger.debug('TTSService', `åŸå§‹æ–‡æœ¬: ${text.substring(0, 100)}${text.length > 100 ? '...' : ''}`);

      // ç”Ÿæˆå”¯ä¸€çš„è¯·æ±‚ID
      speakRequestId = this.generateRequestId();
      this.currentRequestId = speakRequestId;
      this.callbacksMap.set(speakRequestId, callbacks || {});

      // è®¾ç½®TTSæ’­æ”¾å‚æ•°
      const extraParam: Record<string, Object> = {
        "speed": this.config.rate || 1,      // è¯­é€Ÿ
        "volume": Math.round((this.config.volume || 1.0) * 2), // éŸ³é‡ (0-2)
        "pitch": this.config.pitch || 1,     // éŸ³è°ƒ
        "languageContext": this.config.language || 'zh-CN',
        "audioType": "pcm"
      };

      const speakParams: textToSpeech.SpeakParams = {
        requestId: speakRequestId,
        extraParams: extraParam
      };

      // è°ƒç”¨åä¸ºTTS APIå¼€å§‹æ’­æ”¾è¿‡æ»¤åçš„æ–‡æœ¬
      if (this.ttsEngine) {
        this.ttsEngine.speak(filteredText, speakParams);
      }
      
      return true;

    } catch (error) {
      const err = error as Error;
      Logger.error('TTSService', `æ’­æ”¾å¤±è´¥: ${err.message} (é‡è¯•æ¬¡æ•°: ${retryCount})`);

      if (speakRequestId) {
        this.cleanupRequestResources(speakRequestId);

        if (this.currentRequestId === speakRequestId) {
          this.currentRequestId = '';
        }
      }

      this.currentText = '';

      // å¦‚æœè¿˜æœ‰é‡è¯•æœºä¼šï¼Œè¿›è¡Œé‡è¯•
      if (retryCount < this.maxRetries) {
        Logger.info('TTSService', `æ’­æ”¾å¤±è´¥ï¼Œè¿›è¡Œç¬¬ ${retryCount + 1} æ¬¡é‡è¯•`);
        await this.delay(this.retryDelay);
        return this.speakWithRetry(text, callbacks, retryCount + 1);
      }
      
      // è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œè®¾ç½®é”™è¯¯çŠ¶æ€
      this.currentState = TTSState.ERROR;
      this.callbacks = {};
      callbacks?.onError?.(err);
      return false;
    }
  }

  /**
   * åœæ­¢æ’­æ”¾
   */
  async stop(): Promise<boolean> {
    return await this.stopWithMode(false);
  }

  /**
   * å¼ºåˆ¶åœæ­¢æ’­æ”¾
   */
  async forceStop(): Promise<boolean> {
    return await this.stopWithMode(true);
  }

  /**
   * å¸¦æ¨¡å¼çš„åœæ­¢æ–¹æ³•ï¼ˆæ™®é€š/å¼ºåˆ¶ï¼‰
   */
  private async stopWithMode(forceMode: boolean): Promise<boolean> {
    const operation = forceMode ? 'å¼ºåˆ¶åœæ­¢' : 'åœæ­¢';
    Logger.info('TTSService', `${operation}åä¸ºTTSæ’­æ”¾ï¼Œå½“å‰çŠ¶æ€: ${this.currentState}`);

    // å¼ºåˆ¶æ¨¡å¼ä¸‹ä¸æ£€æŸ¥çŠ¶æ€
    if (!forceMode && !this.isPlaying() && !this.isPaused()) {
      Logger.info('TTSService', 'å½“å‰ä¸åœ¨æ’­æ”¾æˆ–æš‚åœçŠ¶æ€ï¼Œæ— éœ€åœæ­¢');
      return true;
    }

    // å¼ºåˆ¶æ¨¡å¼ä¸‹ä¸æ£€æŸ¥å¼•æ“çŠ¶æ€
    if (!forceMode && (!this.isEngineReady || !this.ttsEngine)) {
      Logger.error('TTSService', 'TTSå¼•æ“æœªå‡†å¤‡å°±ç»ª');
      return false;
    }

    try {
      // ä¿å­˜å½“å‰è¯·æ±‚IDç”¨äºåœæ­¢
      const requestToStop = this.currentRequestId;
      let resolvedRequestId = requestToStop;

      // å¦‚æœå½“å‰è¯·æ±‚IDç¼ºå¤±ï¼Œä½†ä»å­˜åœ¨æœªæ¸…ç†çš„å›è°ƒï¼Œå°è¯•å…œåº•å¤„ç†
      if (!resolvedRequestId && this.callbacksMap.size === 1) {
        resolvedRequestId = Array.from(this.callbacksMap.keys())[0];
        Logger.warn('TTSService', `å½“å‰è¯·æ±‚IDç¼ºå¤±ï¼Œä½¿ç”¨å›é€€è¯·æ±‚IDæ‰§è¡Œåœæ­¢: ${resolvedRequestId}`);
      } else if (!resolvedRequestId && this.callbacksMap.size > 1) {
        Logger.warn('TTSService', `å½“å‰è¯·æ±‚IDç¼ºå¤±ä¸”å­˜åœ¨å¤šä¸ªå¾…æ¸…ç†è¯·æ±‚ï¼Œæ— æ³•å”¯ä¸€æ˜ å°„: ${Array.from(this.callbacksMap.keys()).join(', ')}`);
      }

      const callbacks = resolvedRequestId ? this.callbacksMap.get(resolvedRequestId) : this.callbacks;
      
      // ç«‹å³é‡ç½®çŠ¶æ€ï¼Œé˜²æ­¢æ–°çš„æ’­æ”¾è¯·æ±‚
      this.currentState = TTSState.STOPPED;
      this.currentText = '';
      this.currentRequestId = '';
      this.callbacks = {};

      // å¦‚æœæœ‰å¼•æ“ä¸”æœ‰è¯·æ±‚IDï¼Œå°è¯•è°ƒç”¨åœæ­¢
      if (this.ttsEngine) {
        try {
          Logger.info('TTSService', `è°ƒç”¨åä¸ºTTS APIåœæ­¢æ’­æ”¾${resolvedRequestId ? `ï¼Œè¯·æ±‚ID: ${resolvedRequestId}` : 'ï¼ˆæ— æœ‰æ•ˆè¯·æ±‚IDï¼‰'}`);
          this.ttsEngine.stop();

          // ç­‰å¾…çŸ­æš‚æ—¶é—´è®©åœæ­¢å‘½ä»¤ç”Ÿæ•ˆ
          if (!forceMode) {
            await this.delay(100);
          }
          
        } catch (engineError) {
          Logger.error('TTSService', `åä¸ºTTSåœæ­¢å‘½ä»¤å¤±è´¥: ${(engineError as Error).message}`);
          
          if (!forceMode) {
            // éå¼ºåˆ¶æ¨¡å¼ä¸‹ï¼Œå¼•æ“åœæ­¢å¤±è´¥è§†ä¸ºå¤±è´¥
            return false;
          }
          // å¼ºåˆ¶æ¨¡å¼ä¸‹ç»§ç»­æ‰§è¡Œ
        }
      } else {
        Logger.warn('TTSService', `${operation}æ—¶å¼•æ“æˆ–è¯·æ±‚IDæ— æ•ˆ - å¼•æ“: ${this.ttsEngine ? 'æœ‰æ•ˆ' : 'æ— æ•ˆ'}, è¯·æ±‚ID: ${resolvedRequestId || 'æ— '}`);
      }

      // è§¦å‘åœæ­¢å›è°ƒ
      if (callbacks && callbacks.onStop) {
        try {
          callbacks.onStop();
        } catch (callbackError) {
          Logger.error('TTSService', `åœæ­¢å›è°ƒæ‰§è¡Œå¤±è´¥: ${(callbackError as Error).message}`);
        }
      }

      if (resolvedRequestId) {
        this.cleanupRequestResources(resolvedRequestId);
      }

      Logger.info('TTSService', `${operation}æ’­æ”¾å®Œæˆ`);
      return true;

    } catch (error) {
      const err = error as Error;
      Logger.error('TTSService', `${operation}æ’­æ”¾å¤±è´¥: ${err.message}`);
      
      // å¼ºåˆ¶æ¨¡å¼ä¸‹å³ä½¿å‡ºé”™ä¹Ÿè¦é‡ç½®çŠ¶æ€
      if (forceMode) {
        this.currentState = TTSState.STOPPED;
        this.currentText = '';
        this.currentRequestId = '';
        Logger.info('TTSService', 'å¼ºåˆ¶æ¨¡å¼ï¼šå³ä½¿å‡ºç°é”™è¯¯ä¹Ÿé‡ç½®çŠ¶æ€');
        return true;
      }
      
      return false;
    }
  }

  /**
   * æš‚åœæ’­æ”¾
   * æ³¨æ„ï¼šåä¸ºTTS APIå¯èƒ½ä¸æ”¯æŒæš‚åœåŠŸèƒ½ï¼Œè¿™é‡Œä½¿ç”¨åœæ­¢ä½œä¸ºæ›¿ä»£æ–¹æ¡ˆ
   */
  async pause(): Promise<boolean> {
    if (!this.isPlaying()) {
      return true;
    }

    try {
      Logger.info('TTSService', 'æš‚åœTTSæ’­æ”¾ï¼ˆä½¿ç”¨åœæ­¢ä½œä¸ºæ›¿ä»£ï¼‰');
      
      // åä¸ºTTS APIå¯èƒ½ä¸æ”¯æŒæš‚åœï¼Œä½¿ç”¨åœæ­¢æ›¿ä»£
      const success = await this.stop();
      if (success) {
        this.currentState = TTSState.PAUSED;
        this.callbacks.onPause?.();
      }
      return success;
    } catch (error) {
      const err = error as Error;
      Logger.error('TTSService', `æš‚åœæ’­æ”¾å¤±è´¥: ${err.message}`);
      return false;
    }
  }

  /**
   * æ¢å¤æ’­æ”¾
   * æ³¨æ„ï¼šåä¸ºTTS APIå¯èƒ½ä¸æ”¯æŒæ¢å¤åŠŸèƒ½ï¼Œè¿™é‡Œä½¿ç”¨é‡æ–°æ’­æ”¾ä½œä¸ºæ›¿ä»£æ–¹æ¡ˆ
   */
  async resume(): Promise<boolean> {
    if (this.currentState !== TTSState.PAUSED) {
      return true;
    }

    try {
      Logger.info('TTSService', 'æ¢å¤TTSæ’­æ”¾ï¼ˆä½¿ç”¨é‡æ–°æ’­æ”¾ä½œä¸ºæ›¿ä»£ï¼‰');
      
      // å¦‚æœæœ‰ä¿å­˜çš„æ–‡æœ¬ï¼Œé‡æ–°æ’­æ”¾
      if (this.currentText) {
        const success = await this.speak(this.currentText);
        if (success) {
          this.callbacks.onResume?.();
        }
        return success;
      }
      
      return true;
    } catch (error) {
      const err = error as Error;
      Logger.error('TTSService', `æ¢å¤æ’­æ”¾å¤±è´¥: ${err.message}`);
      return false;
    }
  }

  /**
   * æ›´æ–°é…ç½®
   */
  updateConfig(config: Partial<TTSConfig>): void {
    const oldConfig: TTSConfig = {
      language: this.config.language,
      voice: this.config.voice,
      rate: this.config.rate,
      pitch: this.config.pitch,
      volume: this.config.volume
    };
    
    if (config.language !== undefined) this.config.language = config.language;
    if (config.voice !== undefined) this.config.voice = config.voice;
    if (config.rate !== undefined) this.config.rate = Math.max(0.1, Math.min(3.0, config.rate));
    if (config.pitch !== undefined) this.config.pitch = Math.max(0.5, Math.min(2.0, config.pitch));
    if (config.volume !== undefined) this.config.volume = Math.max(0.0, Math.min(1.0, config.volume));
    
    Logger.info('TTSService', `æ›´æ–°TTSé…ç½®: ${JSON.stringify(this.config)}`);
    
    // å¦‚æœè¯­è¨€å‘ç”Ÿå˜åŒ–ï¼Œéœ€è¦é‡æ–°åˆå§‹åŒ–TTSå¼•æ“
    if (oldConfig.language !== this.config.language && this.isEngineReady) {
      Logger.info('TTSService', 'è¯­è¨€é…ç½®å·²æ›´æ”¹ï¼Œéœ€è¦é‡æ–°åˆå§‹åŒ–TTSå¼•æ“');
      this.reinitializeEngine();
    }
  }

  /**
   * è·å–å½“å‰çŠ¶æ€
   */
  getState(): TTSState {
    return this.currentState;
  }

  /**
   * è·å–å½“å‰æ’­æ”¾æ–‡æœ¬
   */
  getCurrentText(): string {
    return this.currentText;
  }

  /**
   * æ£€æŸ¥æ˜¯å¦æ­£åœ¨æ’­æ”¾
   */
  isPlaying(): boolean {
    return this.currentState === TTSState.PLAYING;
  }

  /**
   * æ£€æŸ¥æ˜¯å¦å·²æš‚åœ
   */
  isPaused(): boolean {
    return this.currentState === TTSState.PAUSED;
  }

  /**
   * æ£€æŸ¥æ˜¯å¦å¯ä»¥æ’­æ”¾
   */
  canPlay(): boolean {
    return this.currentState === TTSState.IDLE || 
           this.currentState === TTSState.STOPPED ||
           this.currentState === TTSState.ERROR;
  }

  /**
   * ç­‰å¾…æŒ‡å®šçŠ¶æ€
   */
  private async waitForState(targetStates: TTSState[], timeoutMs: number = 5000): Promise<boolean> {
    return new Promise((resolve) => {
      if (targetStates.includes(this.currentState)) {
        resolve(true);
        return;
      }

      const startTime = Date.now();
      const checkInterval = setInterval(() => {
        if (targetStates.includes(this.currentState)) {
          clearInterval(checkInterval);
          resolve(true);
        } else if (Date.now() - startTime > timeoutMs) {
          clearInterval(checkInterval);
          resolve(false);
        }
      }, 100);
    });
  }

  /**
   * æ¸…ç†æŒ‡å®šè¯·æ±‚çš„å›è°ƒå’Œæ ‡è®°
   */
  private cleanupRequestResources(requestId: string): void {
    if (!requestId) {
      return;
    }

    if (this.callbacksMap.has(requestId)) {
      this.callbacksMap.delete(requestId);
    }

    if (this.callbacksMap.size === 0 && !this.currentRequestId) {
      this.callbacks = {};
    }
  }

  /**
   * ç”Ÿæˆå”¯ä¸€è¯·æ±‚ID
   */
  private generateRequestId(): string {
    this.requestCounter = (this.requestCounter + 1) % 100000;
    const timestamp = systemDateTime.getTime();
    return `${timestamp}-${this.requestCounter}`;
  }

  /**
   * é‡æ–°åˆå§‹åŒ–TTSå¼•æ“ï¼ˆå½“é…ç½®æ›´æ”¹æ—¶ï¼‰
   */
  private async reinitializeEngine(): Promise<void> {
    try {
      Logger.info('TTSService', 'é‡æ–°åˆå§‹åŒ–TTSå¼•æ“');
      
      // å…ˆé”€æ¯ç°æœ‰å¼•æ“
      if (this.ttsEngine) {
        this.ttsEngine.shutdown();
        this.ttsEngine = null;
      }
      
      this.isEngineReady = false;
      
      // é‡æ–°åˆå§‹åŒ–
      await this.initialize();
    } catch (error) {
      const err = error as Error;
      Logger.error('TTSService', `é‡æ–°åˆå§‹åŒ–TTSå¼•æ“å¤±è´¥: ${err.message}`);
    }
  }

  /**
   * è¾…åŠ©å»¶è¿Ÿå‡½æ•°
   */
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * æ£€æŸ¥TTSå¼•æ“å¥åº·çŠ¶æ€
   */
  async checkEngineHealth(): Promise<boolean> {
    try {
      if (!this.ttsEngine) {
        return false;
      }
      
      // ç®€å•çš„å¥åº·æ£€æŸ¥ï¼šå°è¯•è·å–å¼•æ“çŠ¶æ€
      return this.isEngineReady && this.ttsEngine !== null;
    } catch (error) {
      const err = error as Error;
      Logger.error('TTSService', `TTSå¼•æ“å¥åº·æ£€æŸ¥å¤±è´¥: ${err.message}`);
      return false;
    }
  }

  /**
   * è·å–è¯¦ç»†çš„æœåŠ¡çŠ¶æ€ä¿¡æ¯
   */
  getServiceStatus(): TTSServiceStatus {
    const status: TTSServiceStatus = {
      isReady: this.isEngineReady,
      currentState: this.currentState,
      hasActiveRequest: !!this.currentRequestId,
      config: {
        language: this.config.language,
        voice: this.config.voice,
        rate: this.config.rate,
        pitch: this.config.pitch,
        volume: this.config.volume
      }
    };
    return status;
  }

  /**
   * è®¾ç½®é‡è¯•å‚æ•°
   */
  setRetryConfig(maxRetries: number = 3, retryDelay: number = 1000): void {
    this.maxRetries = Math.max(0, Math.min(10, maxRetries)); // é™åˆ¶åœ¨0-10æ¬¡ä¹‹é—´
    this.retryDelay = Math.max(100, Math.min(5000, retryDelay)); // é™åˆ¶åœ¨100-5000msä¹‹é—´
    Logger.info('TTSService', `æ›´æ–°é‡è¯•é…ç½®: maxRetries=${this.maxRetries}, retryDelay=${this.retryDelay}`);
  }

  /**
   * é”€æ¯TTSæœåŠ¡
   */
  async destroy(): Promise<void> {
    try {
      // åœæ­¢å½“å‰æ’­æ”¾
      if (this.isPlaying() || this.isPaused()) {
        await this.stop();
      }

      // é”€æ¯TTSå¼•æ“
      if (this.ttsEngine) {
        this.ttsEngine.shutdown();
        this.ttsEngine = null;
      }

      // é‡ç½®çŠ¶æ€
      this.isEngineReady = false;
      this.currentState = TTSState.IDLE;
      this.currentText = '';
      this.currentRequestId = '';
      this.callbacksMap.clear();
      this.callbacks = {};

      // é‡æ–°è®¡æ•°è¯·æ±‚IDï¼Œé¿å…æº¢å‡º
      this.requestCounter = 0;
      
      Logger.info('TTSService', 'åä¸ºTTSæœåŠ¡å·²é”€æ¯');
    } catch (error) {
      const err = error as Error;
      Logger.error('TTSService', `é”€æ¯TTSæœåŠ¡å¤±è´¥: ${err.message}`);
    }
  }
}
