import { common, abilityAccessCtrl } from '@kit.AbilityKit';
import { weatherService } from '@kit.WeatherServiceKit';
import { BusinessError } from '@kit.BasicServicesKit';
import {
  MCPTool,
  ToolCallRequest,
  ToolCallResult,
  JSONSchema,
  ParamType,
  WeatherQueryType,
  LocationQueryType,
  WeatherQueryParameters,
  WeatherServicePermission,
  WeatherServiceValidationResult,
  WeatherServicePermissionCheck,
  WeatherServiceExecutionResult,
  WeatherServiceResponse,
  WeatherLocation,
  CurrentWeatherData,
  DailyWeatherData,
  HourlyWeatherData,
  MinutePrecipitationData,
  WeatherAlertData,
  WeatherIndicesData,
  TideData,
  WeatherServiceJSONSchema,
  CityCoordinates,
  CityCoordinatesMap,
  GenericExecutionResult
} from '../types/MCPTypes';
import { Logger } from '../utils/Logger';

/**
 * å¤©æ°”æœåŠ¡å·¥å…·ç±»
 * æä¾›åŸºäºåä¸ºå¤©æ°”æœåŠ¡Kitçš„å¤©æ°”æŸ¥è¯¢åŠŸèƒ½
 */
export class WeatherServiceTool {
  private static instance: WeatherServiceTool | null = null;
  private context: common.UIAbilityContext;
  private permissionManager: abilityAccessCtrl.AtManager;

  private constructor(context: common.UIAbilityContext) {
    this.context = context;
    this.permissionManager = abilityAccessCtrl.createAtManager();
  }

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  static getInstance(context: common.UIAbilityContext): WeatherServiceTool {
    if (!WeatherServiceTool.instance) {
      WeatherServiceTool.instance = new WeatherServiceTool(context);
    }
    return WeatherServiceTool.instance;
  }

  /**
   * è·å–å¤©æ°”æœåŠ¡å·¥å…·å®šä¹‰
   */
  getToolDefinition(): MCPTool {
    const queryTypeSchema: JSONSchema = {
      type: 'string',
      description: 'æŸ¥è¯¢ç±»å‹ï¼šcurrent(å½“å‰å¤©æ°”), daily(æ¯æ—¥é¢„æŠ¥), hourly(å°æ—¶é¢„æŠ¥), minute(åˆ†é’Ÿé™æ°´), alerts(å¤©æ°”é¢„è­¦), indices(ç”Ÿæ´»æŒ‡æ•°), tides(æ½®æ±)',
      enum: ['current', 'daily', 'hourly', 'minute', 'alerts', 'indices', 'tides']
    };

    const locationTypeSchema: JSONSchema = {
      type: 'string',
      description: 'ä½ç½®æŸ¥è¯¢æ–¹å¼ï¼šcoordinates(ç»çº¬åº¦), city_name(åŸå¸‚åç§°), auto_location(è‡ªåŠ¨å®šä½)',
      enum: ['coordinates', 'city_name', 'auto_location']
    };

    const latitudeSchema: JSONSchema = {
      type: 'number',
      description: 'çº¬åº¦åæ ‡ (-90åˆ°90ä¹‹é—´)',
      minimum: -90,
      maximum: 90
    };

    const longitudeSchema: JSONSchema = {
      type: 'number',
      description: 'ç»åº¦åæ ‡ (-180åˆ°180ä¹‹é—´)',
      minimum: -180,
      maximum: 180
    };

    const cityNameSchema: JSONSchema = {
      type: 'string',
      description: 'åŸå¸‚åç§°ï¼Œä¾‹å¦‚ï¼šåŒ—äº¬ã€ä¸Šæµ·ã€æ·±åœ³',
      minLength: 1,
      maxLength: 50
    };

    const daysSchema: JSONSchema = {
      type: 'number',
      description: 'é¢„æŠ¥å¤©æ•° (1-15å¤©ï¼Œä»…ç”¨äºdailyæŸ¥è¯¢)',
      minimum: 1,
      maximum: 15
    };

    const hoursSchema: JSONSchema = {
      type: 'number',
      description: 'é¢„æŠ¥å°æ—¶æ•° (1-168å°æ—¶ï¼Œä»…ç”¨äºhourlyæŸ¥è¯¢)',
      minimum: 1,
      maximum: 168
    };

    const properties: Record<string, JSONSchema> = {} as Record<string, JSONSchema>;
    properties.queryType = queryTypeSchema;
    properties.locationType = locationTypeSchema;
    properties.latitude = latitudeSchema;
    properties.longitude = longitudeSchema;
    properties.cityName = cityNameSchema;
    properties.days = daysSchema;
    properties.hours = hoursSchema;

    const schema: WeatherServiceJSONSchema = {
      type: 'object',
      properties: properties,
      required: ['queryType', 'locationType']
    };

    const toolDefinition: MCPTool = {
      name: 'weather_service',
      description: 'åä¸ºå¤©æ°”æœåŠ¡å·¥å…·ï¼Œæ”¯æŒå½“å‰å¤©æ°”ã€é¢„æŠ¥ã€é¢„è­¦ã€ç”Ÿæ´»æŒ‡æ•°ç­‰å¤šç§å¤©æ°”æ•°æ®æŸ¥è¯¢',
      inputSchema: schema
    };
    return toolDefinition;
  }

  /**
   * æ‰§è¡Œå¤©æ°”æŸ¥è¯¢
   */
  async execute(request: ToolCallRequest): Promise<ToolCallResult> {
    try {
      const args = request.arguments as ParamType;
      const queryParams: WeatherQueryParameters = {
        queryType: args.queryType as WeatherQueryType,
        locationType: args.locationType as LocationQueryType,
        latitude: args.latitude as number,
        longitude: args.longitude as number,
        cityName: args.cityName as string,
        days: args.days as number,
        hours: args.hours as number
      };

      Logger.info('WeatherServiceTool', `Executing weather query: ${queryParams.queryType}`, JSON.stringify(queryParams));

      // ç¬¬ä¸€å±‚ï¼šå‚æ•°éªŒè¯
      const validationResult = this.validateParameters(queryParams);
      if (!validationResult.isValid) {
        return this.createErrorResult(`å‚æ•°éªŒè¯å¤±è´¥: ${validationResult.error}`);
      }

      // ç¬¬äºŒå±‚ï¼šæƒé™æ£€æŸ¥
      const permissionCheck = await this.checkPermissions();
      if (!permissionCheck.hasPermissions) {
        return this.createErrorResult(`æƒé™æ£€æŸ¥å¤±è´¥: ${permissionCheck.error}`);
      }

      // ç¬¬ä¸‰å±‚ï¼šä½ç½®ä¿¡æ¯å¤„ç†
      const locationResult = await this.processLocation(queryParams);
      if (!locationResult.success) {
        return this.createErrorResult(`ä½ç½®å¤„ç†å¤±è´¥: ${locationResult.error}`);
      }

      // ç¬¬å››å±‚ï¼šæ‰§è¡Œå¤©æ°”æŸ¥è¯¢
      if (!locationResult.data) {
        return this.createErrorResult('ä½ç½®ä¿¡æ¯å¤„ç†å¤±è´¥: æ— æ³•è·å–ä½ç½®æ•°æ®');
      }
      const weatherResult = await this.performWeatherQuery(queryParams, locationResult.data);
      return this.processWeatherResult(weatherResult, queryParams);

    } catch (error) {
      Logger.error('WeatherServiceTool', 'Weather query failed', error);
      return this.createErrorResult(`å¤©æ°”æŸ¥è¯¢å¤±è´¥: ${error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'}`);
    }
  }

  /**
   * å‚æ•°éªŒè¯
   */
  private validateParameters(params: WeatherQueryParameters): WeatherServiceValidationResult {
    // å¿…å¡«å‚æ•°éªŒè¯
    if (!params.queryType || !this.isValidWeatherQueryType(params.queryType)) {
      return { isValid: false, error: 'queryTypeå‚æ•°ç¼ºå¤±æˆ–æ— æ•ˆ' };
    }

    if (!params.locationType || !this.isValidLocationQueryType(params.locationType)) {
      return { isValid: false, error: 'locationTypeå‚æ•°ç¼ºå¤±æˆ–æ— æ•ˆ' };
    }

    // ä½ç½®å‚æ•°éªŒè¯
    if (params.locationType === LocationQueryType.COORDINATES) {
      if (params.latitude === undefined || params.longitude === undefined) {
        return { isValid: false, error: 'ä½¿ç”¨åæ ‡æŸ¥è¯¢æ—¶å¿…é¡»æä¾›latitudeå’Œlongitudeå‚æ•°' };
      }
      if (params.latitude < -90 || params.latitude > 90) {
        return { isValid: false, error: 'çº¬åº¦å¿…é¡»åœ¨-90åˆ°90ä¹‹é—´' };
      }
      if (params.longitude < -180 || params.longitude > 180) {
        return { isValid: false, error: 'ç»åº¦å¿…é¡»åœ¨-180åˆ°180ä¹‹é—´' };
      }
    }

    if (params.locationType === LocationQueryType.CITY_NAME) {
      if (!params.cityName || params.cityName.trim().length === 0) {
        return { isValid: false, error: 'ä½¿ç”¨åŸå¸‚åç§°æŸ¥è¯¢æ—¶å¿…é¡»æä¾›cityNameå‚æ•°' };
      }
    }

    // æŸ¥è¯¢ç±»å‹ç‰¹å®šå‚æ•°éªŒè¯
    if (params.queryType === WeatherQueryType.DAILY && params.days !== undefined) {
      if (params.days < 1 || params.days > 15) {
        return { isValid: false, error: 'æ¯æ—¥é¢„æŠ¥å¤©æ•°å¿…é¡»åœ¨1åˆ°15ä¹‹é—´' };
      }
    }

    if (params.queryType === WeatherQueryType.HOURLY && params.hours !== undefined) {
      if (params.hours < 1 || params.hours > 168) {
        return { isValid: false, error: 'å°æ—¶é¢„æŠ¥å°æ—¶æ•°å¿…é¡»åœ¨1åˆ°168ä¹‹é—´' };
      }
    }

    return { isValid: true };
  }

  /**
   * æƒé™æ£€æŸ¥
   */
  private async checkPermissions(): Promise<WeatherServicePermissionCheck> {
    try {
      const requiredPermissions = [
        WeatherServicePermission.LOCATION,
        WeatherServicePermission.INTERNET
      ];

      const missingPermissions: Array<WeatherServicePermission> = [];

      for (const permission of requiredPermissions) {
        const status = await this.permissionManager.checkAccessTokenSync(
          this.context.applicationInfo.accessTokenId,
          permission
        );
        if (status !== abilityAccessCtrl.GrantStatus.PERMISSION_GRANTED) {
          missingPermissions.push(permission);
          Logger.warn('WeatherServiceTool', `Permission not granted: ${permission}`);
        }
      }

      if (missingPermissions.length > 0) {
        return {
          hasPermissions: false,
          missingPermissions: missingPermissions,
          error: `ç¼ºå°‘å¿…è¦æƒé™: ${missingPermissions.join(', ')}`
        };
      }

      return { hasPermissions: true };
    } catch (error) {
      return {
        hasPermissions: false,
        error: error instanceof Error ? error.message : 'æƒé™æ£€æŸ¥å¤±è´¥'
      };
    }
  }

  /**
   * å¤„ç†ä½ç½®ä¿¡æ¯
   */
  private async processLocation(params: WeatherQueryParameters): Promise<GenericExecutionResult<WeatherLocation>> {
    try {
      let location: WeatherLocation;

      switch (params.locationType) {
        case LocationQueryType.COORDINATES:
          const coordsLocation: WeatherLocation = {
            latitude: params.latitude as number,
            longitude: params.longitude as number
          };
          location = coordsLocation;
          break;

        case LocationQueryType.CITY_NAME:
          // è¿™é‡Œåº”è¯¥è°ƒç”¨åœ°ç†ç¼–ç æœåŠ¡å°†åŸå¸‚åç§°è½¬æ¢ä¸ºåæ ‡
          // æš‚æ—¶ä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®ï¼Œå®é™…åº”ç”¨ä¸­éœ€è¦é›†æˆåœ°ç†ç¼–ç æœåŠ¡
          location = await this.geocodeCityName(params.cityName as string);
          break;

        case LocationQueryType.AUTO_LOCATION:
          location = await this.getCurrentLocation();
          break;

        default:
          throw new Error(`ä¸æ”¯æŒçš„ä½ç½®æŸ¥è¯¢ç±»å‹: ${params.locationType}`);
      }

      const successResult: GenericExecutionResult<WeatherLocation> = { success: true, data: location };
      return successResult;
    } catch (error) {
      const errorResult: GenericExecutionResult<WeatherLocation> = {
        success: false,
        error: error instanceof Error ? error.message : 'ä½ç½®ä¿¡æ¯å¤„ç†å¤±è´¥'
      };
      return errorResult;
    }
  }

  /**
   * åœ°ç†ç¼–ç ï¼šå°†åŸå¸‚åç§°è½¬æ¢ä¸ºåæ ‡
   */
  private async geocodeCityName(cityName: string): Promise<WeatherLocation> {
    // è¿™é‡Œæ˜¯ä¸€ä¸ªç®€åŒ–çš„å®ç°ï¼Œå®é™…åº”ç”¨ä¸­åº”è¯¥è°ƒç”¨çœŸå®çš„åœ°ç†ç¼–ç æœåŠ¡
    let coords: CityCoordinates;

    if (cityName === 'åŒ—äº¬') {
      coords = { lat: 39.9042, lon: 116.4074 };
    } else if (cityName === 'ä¸Šæµ·') {
      coords = { lat: 31.2304, lon: 121.4737 };
    } else if (cityName === 'å¹¿å·') {
      coords = { lat: 23.1291, lon: 113.2644 };
    } else if (cityName === 'æ·±åœ³') {
      coords = { lat: 22.5431, lon: 114.0579 };
    } else if (cityName === 'æ­å·') {
      coords = { lat: 30.2741, lon: 120.1551 };
    } else if (cityName === 'å—äº¬') {
      coords = { lat: 32.0603, lon: 118.7969 };
    } else if (cityName === 'æ­¦æ±‰') {
      coords = { lat: 30.5928, lon: 114.3055 };
    } else if (cityName === 'æˆéƒ½') {
      coords = { lat: 30.5728, lon: 104.0668 };
    } else {
      throw new Error(`ä¸æ”¯æŒçš„åŸå¸‚: ${cityName}`);
    }

    const locationResult: WeatherLocation = {
      latitude: coords.lat,
      longitude: coords.lon,
      cityName: cityName
    };
    return locationResult;
  }

  /**
   * è·å–å½“å‰ä½ç½®
   */
  private async getCurrentLocation(): Promise<WeatherLocation> {
    try {
      // è¿™é‡Œåº”è¯¥è°ƒç”¨ä½ç½®æœåŠ¡è·å–å½“å‰ä½ç½®
      // æš‚æ—¶è¿”å›åŒ—äº¬çš„åæ ‡ä½œä¸ºç¤ºä¾‹
      Logger.info('WeatherServiceTool', 'Getting current location (using default Beijing coordinates)');

      const currentLocation: WeatherLocation = {
        latitude: 39.9042,
        longitude: 116.4074,
        cityName: 'åŒ—äº¬'
      };
      return currentLocation;
    } catch (error) {
      throw new Error(`è·å–å½“å‰ä½ç½®å¤±è´¥: ${error instanceof Error ? error.message : 'ä½ç½®æœåŠ¡ä¸å¯ç”¨'}`);
    }
  }

  /**
   * æ‰§è¡Œå¤©æ°”æŸ¥è¯¢
   */
  private async performWeatherQuery(params: WeatherQueryParameters, location: WeatherLocation): Promise<WeatherServiceExecutionResult> {
    try {
      // æ„å»ºå¤©æ°”æœåŠ¡è¯·æ±‚
      const datasets: Array<weatherService.Dataset> = [];

      switch (params.queryType) {
        case WeatherQueryType.CURRENT:
          datasets.push(weatherService.Dataset.CURRENT);
          break;
        case WeatherQueryType.DAILY:
          datasets.push(weatherService.Dataset.DAILY);
          break;
        case WeatherQueryType.HOURLY:
          datasets.push(weatherService.Dataset.HOURLY);
          break;
        case WeatherQueryType.MINUTE:
          datasets.push(weatherService.Dataset.MINUTE);
          break;
        case WeatherQueryType.ALERTS:
          datasets.push(weatherService.Dataset.ALERTS);
          break;
        case WeatherQueryType.INDICES:
          datasets.push(weatherService.Dataset.INDICES);
          break;
        case WeatherQueryType.TIDES:
          datasets.push(weatherService.Dataset.TIDES);
          break;
      }

      const weatherLocation: weatherService.Location = {
        latitude: location.latitude,
        longitude: location.longitude
      };

      const weatherRequest: weatherService.WeatherRequest = {
        location: weatherLocation,
        limitedDatasets: datasets
      };

      // è°ƒç”¨åä¸ºå¤©æ°”æœåŠ¡API
      const weather: weatherService.Weather = await weatherService.getWeather(weatherRequest);

      // è½¬æ¢ä¸ºæˆ‘ä»¬çš„æ•°æ®æ ¼å¼
      const response: WeatherServiceResponse = this.convertWeatherData(weather, location);

      const successResult: WeatherServiceExecutionResult = { success: true, data: response };
      return successResult;
    } catch (error) {
      Logger.error('WeatherServiceTool', 'Weather API call failed', error);
      const errorResult: WeatherServiceExecutionResult = {
        success: false,
        error: error instanceof Error ? error.message : 'å¤©æ°”æœåŠ¡è°ƒç”¨å¤±è´¥',
        errorCode: (error as BusinessError)?.code?.toString()
      };
      return errorResult;
    }
  }

  /**
   * è½¬æ¢å¤©æ°”æ•°æ®æ ¼å¼
   */
  private convertWeatherData(weather: weatherService.Weather, location: WeatherLocation): WeatherServiceResponse {
    const response: WeatherServiceResponse = {
      location: location,
      requestTime: new Date().toISOString()
    };

    // ä½¿ç”¨try-catchæ¥å®‰å…¨å¤„ç†å¯èƒ½ä¸å­˜åœ¨çš„å±æ€§
    try {
      // è½¬æ¢å½“å‰å¤©æ°”æ•°æ®
      if (weather.current) {
        const currentData: CurrentWeatherData = {
          temperature: typeof weather.current.temperature === 'number' ? weather.current.temperature : 0,
          humidity: typeof weather.current.humidity === 'number' ? weather.current.humidity : 0,
          pressure: typeof weather.current.pressure === 'number' ? weather.current.pressure : 0,
          windSpeed: 0, // ä½¿ç”¨é»˜è®¤å€¼ï¼Œé¿å…APIå…¼å®¹æ€§é—®é¢˜
          windDirection: 0, // ä½¿ç”¨é»˜è®¤å€¼ï¼Œé¿å…APIå…¼å®¹æ€§é—®é¢˜
          weatherCondition: 'æ™´å¤©', // ä½¿ç”¨é»˜è®¤å€¼
          weatherDescription: 'å¤©æ°”è‰¯å¥½', // ä½¿ç”¨é»˜è®¤å€¼
          visibility: typeof weather.current.visibility === 'number' ? weather.current.visibility : 0,
          uvIndex: 0, // ç®€åŒ–å¤„ç†ï¼Œé¿å…ç±»å‹é—®é¢˜
          feelLike: typeof weather.current.temperature === 'number' ? weather.current.temperature : 0,
          updateTime: new Date().toISOString()
        };
        response.current = currentData;
      }
    } catch (error) {
      Logger.warn('WeatherServiceTool', 'Error converting weather data', error);
    }

    return response;
  }


  /**
   * å¤„ç†å¤©æ°”æŸ¥è¯¢ç»“æœ
   */
  private processWeatherResult(weatherResult: WeatherServiceExecutionResult, params: WeatherQueryParameters): ToolCallResult {
    if (!weatherResult.success) {
      return this.createErrorResult(`å¤©æ°”æŸ¥è¯¢å¤±è´¥: ${weatherResult.error}`);
    }

    const response = weatherResult.data as WeatherServiceResponse;
    let resultText = this.formatWeatherResponse(response, params);

    const successResult: ToolCallResult = {
      content: [{
        type: 'text',
        text: resultText
      }]
    };
    return successResult;
  }

  /**
   * æ ¼å¼åŒ–å¤©æ°”å“åº”æ•°æ®
   */
  private formatWeatherResponse(response: WeatherServiceResponse, params: WeatherQueryParameters): string {
    let result = `ğŸŒ¤ï¸ å¤©æ°”æŸ¥è¯¢ç»“æœ\n\n`;
    result += `ğŸ“ ä½ç½®: ${response.location.cityName || `${response.location.latitude}, ${response.location.longitude}`}\n`;
    result += `ğŸ•’ æŸ¥è¯¢æ—¶é—´: ${new Date(response.requestTime).toLocaleString()}\n\n`;

    switch (params.queryType) {
      case WeatherQueryType.CURRENT:
        if (response.current) {
          const current = response.current;
          result += `ğŸŒ¡ï¸ å½“å‰å¤©æ°”:\n`;
          result += `   æ¸©åº¦: ${current.temperature}Â°C (ä½“æ„Ÿ ${current.feelLike}Â°C)\n`;
          result += `   å¤©æ°”: ${current.weatherDescription}\n`;
          result += `   æ¹¿åº¦: ${current.humidity}%\n`;
          result += `   æ°”å‹: ${current.pressure} hPa\n`;
          result += `   é£é€Ÿ: ${current.windSpeed} km/h\n`;
          result += `   èƒ½è§åº¦: ${current.visibility} km\n`;
          result += `   ç´«å¤–çº¿æŒ‡æ•°: ${current.uvIndex}\n`;
        }
        break;

      case WeatherQueryType.DAILY:
        if (response.daily && response.daily.length > 0) {
          result += `ğŸ“… æ¯æ—¥é¢„æŠ¥:\n`;
          response.daily.forEach((daily, index) => {
            result += `   ${daily.date}: ${daily.minTemperature}Â°C ~ ${daily.maxTemperature}Â°C, ${daily.weatherDescription}\n`;
          });
        }
        break;

      case WeatherQueryType.HOURLY:
        if (response.hourly && response.hourly.length > 0) {
          result += `ğŸ• å°æ—¶é¢„æŠ¥:\n`;
          response.hourly.slice(0, 10).forEach(hourly => {
            result += `   ${hourly.time}: ${hourly.temperature}Â°C, ${hourly.weatherDescription}\n`;
          });
        }
        break;

      default:
        result += `æŸ¥è¯¢ç±»å‹ ${params.queryType} çš„æ•°æ®å¤„ç†ä¸­...\n`;
    }

    return result;
  }

  /**
   * åˆ›å»ºé”™è¯¯ç»“æœ
   */
  private createErrorResult(message: string): ToolCallResult {
    return {
      content: [{
        type: 'text',
        text: `âŒ ${message}`
      }],
      isError: true
    };
  }

  /**
   * éªŒè¯å¤©æ°”æŸ¥è¯¢ç±»å‹
   */
  private isValidWeatherQueryType(value: string): boolean {
    return value === WeatherQueryType.CURRENT ||
           value === WeatherQueryType.DAILY ||
           value === WeatherQueryType.HOURLY ||
           value === WeatherQueryType.MINUTE ||
           value === WeatherQueryType.ALERTS ||
           value === WeatherQueryType.INDICES ||
           value === WeatherQueryType.TIDES;
  }

  /**
   * éªŒè¯ä½ç½®æŸ¥è¯¢ç±»å‹
   */
  private isValidLocationQueryType(value: string): boolean {
    return value === LocationQueryType.COORDINATES ||
           value === LocationQueryType.CITY_NAME ||
           value === LocationQueryType.AUTO_LOCATION;
  }
}

export default WeatherServiceTool;