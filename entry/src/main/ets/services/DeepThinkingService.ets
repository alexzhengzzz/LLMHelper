/**
 * æ·±åº¦æ€è€ƒæœåŠ¡ - å®ç°å¤šè½®æ¨ç†å¼•æ“
 */

import { Message, MessageRole, ThinkingStep, ThinkingStatus, StepStatus, SimpleMessage } from '../models/ChatModels';
import { APIManager, APIMode } from './APIManager';
import { ChatRequest as APIChatRequest, ChatMessage as APIChatMessage } from '../types/APITypes';
import { Logger } from '../utils/Logger';
import { ContentCompressor } from './ContentCompressor';

// æ·±åº¦æ€è€ƒé…ç½®
interface DeepThinkingConfig {
  maxRetries: number;        // æœ€å¤§é‡è¯•æ¬¡æ•°
  timeoutMs: number;         // å•æ­¥è¶…æ—¶æ—¶é—´
  fallbackEnabled: boolean;  // æ˜¯å¦å¯ç”¨é™çº§
  temperature: number;       // æ¸©åº¦å‚æ•°
  maxTokens: number;         // æœ€å¤§tokenæ•°
}

// å®Œæˆæ­¥éª¤æ¥å£
interface CompletedStep {
  content: string;
  type: string;
}

// æ·±åº¦æ€è€ƒæ­¥éª¤å®šä¹‰
interface StepDefinition {
  id: string;
  title: string;
  description: string;
  prompt: string;
}

// æ·±åº¦æ€è€ƒç»“æœ
export interface DeepThinkingResult {
  success: boolean;
  finalAnswer: string;
  steps: ThinkingStep[];
  totalTime: number;
  fallbackUsed: boolean;
  error?: string;
}

// è¿›åº¦å›è°ƒ
export interface DeepThinkingCallbacks {
  onStepStart?: (step: ThinkingStep) => void;
  onStepComplete?: (step: ThinkingStep) => void;
  onStepError?: (step: ThinkingStep, error: string) => void;
  onProgress?: (currentStep: number, totalSteps: number) => void;
  onComplete?: (result: DeepThinkingResult) => void;
  onError?: (error: string) => void;
}

/**
 * æ·±åº¦æ€è€ƒæœåŠ¡
 */
export class DeepThinkingService {
  private static instance: DeepThinkingService;
  private apiManager: APIManager;
  private config: DeepThinkingConfig;
  private stepDefinitions: StepDefinition[];
  private contentCompressor: ContentCompressor;
  private isProcessing: boolean = false;
  private currentProcessId: string | null = null;
  private cancellationToken: boolean = false;

  private constructor() {
    this.apiManager = APIManager.getInstance();
    this.contentCompressor = ContentCompressor.getInstance();
    this.config = {
      maxRetries: 2,
      timeoutMs: 120000, // 120ç§’è¶…æ—¶
      fallbackEnabled: true,
      temperature: 0.9,
      maxTokens: 10000
    };
    
    // å®šä¹‰å›ºå®šçš„4æ­¥æ¨ç†æ¡†æ¶
    this.stepDefinitions = [
      {
        id: 'analyze',
        title: 'ğŸ” æ·±åº¦åˆ†æ',
        description: 'åˆ†æé—®é¢˜çš„æ ¸å¿ƒè¦ç‚¹å’Œå…³é”®ä¿¡æ¯',
        prompt: 'åˆ†æé—®é¢˜çš„æ ¸å¿ƒè¦ç‚¹å’Œå…³é”®å› ç´ ï¼š{question}\n\nè¯·æä¾›ï¼š\n1. æ ¸å¿ƒè¦ç‚¹\n2. å…³é”®å› ç´ \n3. å¤æ‚æ€§å’ŒæŒ‘æˆ˜'
      },
      {
        id: 'think',
        title: 'ğŸ§  å¤šè§’åº¦æ€è€ƒ',
        description: 'ä»å¤šä¸ªè§’åº¦æ·±å…¥æ€è€ƒå¯èƒ½çš„è§£å†³æ–¹æ¡ˆ',
        prompt: 'åŸºäºåˆ†æç»“æœæ€è€ƒè§£å†³æ–¹æ¡ˆï¼š{question}\n\nå‰åˆ†æï¼š{previousStep}\n\nè¯·è€ƒè™‘ï¼š\n1. ç†è®ºå’Œå®è·µæ–¹æ¡ˆ\n2. ä¸åŒè§’åº¦è§‚ç‚¹\n3. é£é™©å’Œæœºé‡'
      },
      {
        id: 'verify',
        title: 'âœ… æ‰¹åˆ¤æ€§éªŒè¯',
        description: 'æ‰¹åˆ¤æ€§åœ°éªŒè¯å’Œåé©³å‰é¢çš„æ€è€ƒç»“æœ',
        prompt: 'æ‰¹åˆ¤æ€§å®¡è§†å‰é¢çš„åˆ†æå’Œæ€è€ƒï¼š{question}\n\nåˆ†æï¼š{step1}\næ€è€ƒï¼š{step2}\n\nè¯·éªŒè¯ï¼š\n1. é€»è¾‘æ¼æ´\n2. åé©³è§‚ç‚¹\n3. é—æ¼å› ç´ \n4. åä¾‹æƒ…å†µ'
      },
      {
        id: 'integrate',
        title: 'ğŸ¯ ç»¼åˆæ•´åˆ',
        description: 'æ•´åˆæ‰€æœ‰æ€è€ƒç»“æœï¼Œæä¾›æœ€ç»ˆçš„ç»¼åˆæ€§ç­”æ¡ˆ',
        prompt: 'æ•´åˆæ‰€æœ‰æ€è€ƒç»“æœï¼Œæä¾›æœ€ç»ˆç­”æ¡ˆï¼š{question}\n\nåˆ†æï¼š{step1}\næ€è€ƒï¼š{step2}\néªŒè¯ï¼š{step3}\n\nè¯·æä¾›ï¼š\n1. å…³é”®æ´å¯Ÿ\n2. æ˜ç¡®ç»“è®º\n3. æ¨ç†ä¾æ®\n4. è¡ŒåŠ¨å»ºè®®'
      }
    ];
  }

  public static getInstance(): DeepThinkingService {
    if (!DeepThinkingService.instance) {
      DeepThinkingService.instance = new DeepThinkingService();
    }
    return DeepThinkingService.instance;
  }

  /**
   * å¯åŠ¨æ·±åº¦æ€è€ƒè¿‡ç¨‹
   */
  async startDeepThinking(
    question: string,
    model: string,
    messages: SimpleMessage[],
    callbacks?: DeepThinkingCallbacks
  ): Promise<DeepThinkingResult> {
    if (this.isProcessing) {
      throw new Error('æ·±åº¦æ€è€ƒæœåŠ¡æ­£å¿™ï¼Œè¯·ç¨åå†è¯•');
    }

    this.isProcessing = true;
    this.cancellationToken = false;
    this.currentProcessId = this.generateProcessId();
    
    const startTime = Date.now();
    const steps: ThinkingStep[] = [];
    let fallbackUsed = false;
    
    try {
      Logger.info('DeepThinkingService', `å¼€å§‹æ·±åº¦æ€è€ƒè¿‡ç¨‹: ${this.currentProcessId}`);
      Logger.info('DeepThinkingService', `é—®é¢˜: ${question.substring(0, 100)}...`);
      
      // åˆå§‹åŒ–æ‰€æœ‰æ­¥éª¤
      for (const stepDef of this.stepDefinitions) {
        const step = new ThinkingStep(stepDef.id, stepDef.title, stepDef.description);
        steps.push(step);
      }
      
      // ä¾æ¬¡æ‰§è¡Œæ¯ä¸ªæ­¥éª¤
      for (let i = 0; i < this.stepDefinitions.length; i++) {
        if (this.cancellationToken) {
          Logger.info('DeepThinkingService', 'æ·±åº¦æ€è€ƒè¿‡ç¨‹è¢«å–æ¶ˆ');
          throw new Error('æ·±åº¦æ€è€ƒè¿‡ç¨‹è¢«ç”¨æˆ·å–æ¶ˆ');
        }
        
        const stepDef = this.stepDefinitions[i];
        const step = steps[i];
        
        Logger.info('DeepThinkingService', `å¼€å§‹æ‰§è¡Œæ­¥éª¤ ${i + 1}/${this.stepDefinitions.length}: ${step.title}`);
        
        // è§¦å‘æ­¥éª¤å¼€å§‹å›è°ƒ
        callbacks?.onStepStart?.(step);
        callbacks?.onProgress?.(i + 1, this.stepDefinitions.length);
        
        try {
          step.start();
          
          // æ„å»ºæ­¥éª¤ç‰¹å®šçš„æç¤ºè¯
          const stepPrompt = this.buildStepPrompt(stepDef, question, steps, i);
          
          // æ‰§è¡ŒAPIè°ƒç”¨
          const stepResult = await this.executeStep(stepPrompt, model);
          
          step.complete(stepResult);
          Logger.info('DeepThinkingService', `æ­¥éª¤ ${i + 1} å®Œæˆ: ${step.title}`);
          
          // è§¦å‘æ­¥éª¤å®Œæˆå›è°ƒ
          callbacks?.onStepComplete?.(step);
          
        } catch (error) {
          const errorMessage = (error as Error).message;
          Logger.error('DeepThinkingService', `æ­¥éª¤ ${i + 1} æ‰§è¡Œå¤±è´¥: ${errorMessage}`);
          
          step.fail(errorMessage);
          callbacks?.onStepError?.(step, errorMessage);
          
          // æ ¹æ®é…ç½®å†³å®šæ˜¯å¦é™çº§
          if (this.config.fallbackEnabled && i >= 1) {
            Logger.warn('DeepThinkingService', 'å¯ç”¨é™çº§æ¨¡å¼ï¼Œä½¿ç”¨éƒ¨åˆ†ç»“æœ');
            fallbackUsed = true;
            break;
          } else {
            throw error as Error;
          }
        }
      }
      
      // ç”Ÿæˆæœ€ç»ˆç­”æ¡ˆ
      const finalAnswer = this.generateFinalAnswer(steps, fallbackUsed);
      const totalTime = Date.now() - startTime;
      
      const result: DeepThinkingResult = {
        success: true,
        finalAnswer,
        steps,
        totalTime,
        fallbackUsed
      };
      
      Logger.info('DeepThinkingService', `æ·±åº¦æ€è€ƒå®Œæˆï¼Œæ€»è€—æ—¶: ${totalTime}msï¼Œé™çº§: ${fallbackUsed}`);
      callbacks?.onComplete?.(result);
      
      return result;
      
    } catch (error) {
      const errorMessage = (error as Error).message;
      Logger.error('DeepThinkingService', `æ·±åº¦æ€è€ƒå¤±è´¥: ${errorMessage}`);
      
      const totalTime = Date.now() - startTime;
      const result: DeepThinkingResult = {
        success: false,
        finalAnswer: '',
        steps,
        totalTime,
        fallbackUsed,
        error: errorMessage
      };
      
      callbacks?.onError?.(errorMessage);
      return result;
      
    } finally {
      this.isProcessing = false;
      this.currentProcessId = null;
      this.cancellationToken = false;
    }
  }

  /**
   * å–æ¶ˆå½“å‰çš„æ·±åº¦æ€è€ƒè¿‡ç¨‹
   */
  cancel(): boolean {
    if (!this.isProcessing) {
      return false;
    }
    
    Logger.info('DeepThinkingService', 'æ­£åœ¨å–æ¶ˆæ·±åº¦æ€è€ƒè¿‡ç¨‹');
    this.cancellationToken = true;
    return true;
  }

  /**
   * æ£€æŸ¥æ˜¯å¦æ­£åœ¨å¤„ç†
   */
  isRunning(): boolean {
    return this.isProcessing;
  }

  /**
   * è·å–å½“å‰å¤„ç†ID
   */
  getCurrentProcessId(): string | null {
    return this.currentProcessId;
  }

  /**
   * æ„å»ºæ­¥éª¤ç‰¹å®šçš„æç¤ºè¯ï¼ˆä¼˜åŒ–ç‰ˆ - ä½¿ç”¨å†…å®¹å‹ç¼©ï¼‰
   */
  private buildStepPrompt(stepDef: StepDefinition, question: string, steps: ThinkingStep[], currentIndex: number): string {
    let prompt = stepDef.prompt;
    
    // ä½¿ç”¨ç®€åŒ–çš„é—®é¢˜å¼•ç”¨
    const shortQuestion = this.compressQuestion(question);
    prompt = prompt.replace(/{question}/g, shortQuestion);
    
    // ä½¿ç”¨å‹ç¼©åçš„å‰é¢æ­¥éª¤ç»“æœ
    if (currentIndex > 0) {
      const completedSteps: CompletedStep[] = [];
      
      // æ”¶é›†å·²å®Œæˆçš„æ­¥éª¤
      if (steps[0] && steps[0].status === StepStatus.COMPLETED) {
        const step: CompletedStep = {content: steps[0].content, type: 'analyze'};
        completedSteps.push(step);
      }
      if (steps[1] && steps[1].status === StepStatus.COMPLETED) {
        const step: CompletedStep = {content: steps[1].content, type: 'think'};
        completedSteps.push(step);
      }
      if (steps[2] && steps[2].status === StepStatus.COMPLETED) {
        const step: CompletedStep = {content: steps[2].content, type: 'verify'};
        completedSteps.push(step);
      }
      
      // æ ¹æ®å½“å‰æ­¥éª¤æ›¿æ¢ç›¸åº”çš„å ä½ç¬¦
      switch (currentIndex) {
        case 1: // å¤šè§’åº¦æ€è€ƒæ­¥éª¤
          if (completedSteps.length >= 1) {
            const compressed = this.contentCompressor.compressStepContent(completedSteps[0].content, 'analyze');
            const compressedText = this.contentCompressor.buildCompressedPrompt(compressed, 'analyze');
            prompt = prompt.replace(/{previousStep}/g, compressedText);
          }
          break;
          
        case 2: // æ‰¹åˆ¤æ€§éªŒè¯æ­¥éª¤
          if (completedSteps.length >= 1) {
            const compressed1 = this.contentCompressor.compressStepContent(completedSteps[0].content, 'analyze');
            const compressedText1 = this.contentCompressor.buildCompressedPrompt(compressed1, 'analyze');
            prompt = prompt.replace(/{step1}/g, compressedText1);
          }
          if (completedSteps.length >= 2) {
            const compressed2 = this.contentCompressor.compressStepContent(completedSteps[1].content, 'think');
            const compressedText2 = this.contentCompressor.buildCompressedPrompt(compressed2, 'think');
            prompt = prompt.replace(/{step2}/g, compressedText2);
          }
          break;
          
        case 3: // ç»¼åˆæ•´åˆæ­¥éª¤
          if (completedSteps.length >= 1) {
            const compressed1 = this.contentCompressor.compressStepContent(completedSteps[0].content, 'analyze');
            const compressedText1 = this.contentCompressor.buildCompressedPrompt(compressed1, 'analyze');
            prompt = prompt.replace(/{step1}/g, compressedText1);
          }
          if (completedSteps.length >= 2) {
            const compressed2 = this.contentCompressor.compressStepContent(completedSteps[1].content, 'think');
            const compressedText2 = this.contentCompressor.buildCompressedPrompt(compressed2, 'think');
            prompt = prompt.replace(/{step2}/g, compressedText2);
          }
          if (completedSteps.length >= 3) {
            const compressed3 = this.contentCompressor.compressStepContent(completedSteps[2].content, 'verify');
            const compressedText3 = this.contentCompressor.buildCompressedPrompt(compressed3, 'verify');
            prompt = prompt.replace(/{step3}/g, compressedText3);
          }
          break;
      }
    }
    
    Logger.debug('DeepThinkingService', `æ„å»ºæ­¥éª¤${currentIndex + 1}æç¤ºè¯ï¼Œé•¿åº¦: ${prompt.length}`);
    return prompt;
  }

  /**
   * å‹ç¼©é—®é¢˜æè¿°
   */
  private compressQuestion(question: string): string {
    // å¦‚æœé—®é¢˜è¾ƒçŸ­ï¼Œç›´æ¥è¿”å›
    if (question.length <= 100) {
      return question;
    }
    
    // å¦‚æœé—®é¢˜è¾ƒé•¿ï¼Œæå–æ ¸å¿ƒéƒ¨åˆ†
    const sentences = question.split(/[ã€‚ï¼ï¼Ÿ]/).filter(s => s.trim().length > 0);
    if (sentences.length > 1) {
      // å–å‰ä¸¤å¥æˆ–å‰100å­—ç¬¦
      const firstTwoSentences = sentences.slice(0, 2).join('ã€‚');
      return firstTwoSentences.length <= 150 ? firstTwoSentences + 'ã€‚' : firstTwoSentences.substring(0, 100) + '...';
    }
    
    // å•å¥æƒ…å†µä¸‹æˆªæ–­
    return question.substring(0, 100) + '...';
  }

  /**
   * æ‰§è¡Œå•ä¸ªæ­¥éª¤
   */
  private async executeStep(prompt: string, model: string): Promise<string> {
    const messages: APIChatMessage[] = [
      {
        role: 'user',
        content: prompt
      }
    ];

    const apiRequest: APIChatRequest = {
      model,
      messages,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      timeout: this.config.timeoutMs
    };

    Logger.debug('DeepThinkingService', `æ‰§è¡ŒAPIè°ƒç”¨ï¼Œæ¨¡å‹: ${model}`);
    
    const response = await this.apiManager.sendChatRequest(apiRequest);
    
    if (!response.choices || response.choices.length === 0) {
      throw new Error('APIè¿”å›ç©ºå“åº”');
    }

    const content = response.choices[0].message.content;
    if (!content || content.trim().length === 0) {
      throw new Error('APIè¿”å›ç©ºå†…å®¹');
    }

    return content.trim();
  }

  /**
   * ç”Ÿæˆæœ€ç»ˆç­”æ¡ˆ
   */
  private generateFinalAnswer(steps: ThinkingStep[], fallbackUsed: boolean): string {
    const completedSteps = steps.filter(step => step.status === StepStatus.COMPLETED);
    
    if (completedSteps.length === 0) {
      return 'æ·±åº¦æ€è€ƒè¿‡ç¨‹æœªèƒ½å®Œæˆï¼Œæ— æ³•æä¾›ç­”æ¡ˆã€‚';
    }
    
    // å¦‚æœæœ‰å®Œæ•´çš„4æ­¥ï¼Œä½¿ç”¨æœ€åä¸€æ­¥ä½œä¸ºæœ€ç»ˆç­”æ¡ˆ
    if (completedSteps.length === 4 && !fallbackUsed) {
      return completedSteps[3].content;
    }
    
    // é™çº§æ¨¡å¼ï¼šåŸºäºå®Œæˆçš„æ­¥éª¤ç”Ÿæˆç­”æ¡ˆ
    let finalAnswer = 'åŸºäºå·²å®Œæˆçš„åˆ†ææ­¥éª¤ï¼Œä»¥ä¸‹æ˜¯ç»¼åˆæ€§å›ç­”ï¼š\n\n';
    
    for (let i = 0; i < completedSteps.length; i++) {
      const step = completedSteps[i];
      finalAnswer += `## ${step.title}\n${step.content}\n\n`;
    }
    
    if (fallbackUsed) {
      finalAnswer += '> **æ³¨æ„**: ç”±äºéƒ¨åˆ†æ¨ç†æ­¥éª¤æœªèƒ½å®Œæˆï¼Œä»¥ä¸Šä¸ºåŸºäºå·²å®Œæˆæ­¥éª¤çš„é™çº§å›ç­”ã€‚';
    }
    
    return finalAnswer;
  }

  /**
   * ç”Ÿæˆå¤„ç†ID
   */
  private generateProcessId(): string {
    return 'thinking_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
  }

  /**
   * æ›´æ–°é…ç½®
   */
  updateConfig(newConfig: Partial<DeepThinkingConfig>): void {
    this.config.maxRetries = newConfig.maxRetries ?? this.config.maxRetries;
    this.config.timeoutMs = newConfig.timeoutMs ?? this.config.timeoutMs;
    this.config.fallbackEnabled = newConfig.fallbackEnabled ?? this.config.fallbackEnabled;
    this.config.temperature = newConfig.temperature ?? this.config.temperature;
    this.config.maxTokens = newConfig.maxTokens ?? this.config.maxTokens;
    Logger.info('DeepThinkingService', 'é…ç½®å·²æ›´æ–°');
  }

  /**
   * è·å–é…ç½®
   */
  getConfig(): DeepThinkingConfig {
    return {
      maxRetries: this.config.maxRetries,
      timeoutMs: this.config.timeoutMs,
      fallbackEnabled: this.config.fallbackEnabled,
      temperature: this.config.temperature,
      maxTokens: this.config.maxTokens
    };
  }

  /**
   * é”€æ¯æœåŠ¡
   */
  destroy(): void {
    this.cancel();
    Logger.info('DeepThinkingService', 'æœåŠ¡å·²é”€æ¯');
  }
}