import {
  MemoryFragment,
  MemoryCategory,
  MemoryImportance,
  MemoryStats,
  MemoryCategoryCounts,
  MemoryImportanceCounts,
  CreateMemoryRequest,
  UpdateMemoryRequest,
  MemoryFilterOptions,
  MemorySortBy,
  MemorySortDirection,
  MemorySortOptions,
  MemoryOperationResult,
  MemoryInjectionConfig,
  MemoryItem,
  MemorySearchResult,
  HybridSearchResult,
  VectorSearchResult,
  VectorMigrationStatus,
  // ç”¨æˆ·ä¸»åŠ¨è§¦å‘è®°å¿†åŠŸèƒ½ç›¸å…³ç±»å‹
  MemoryTriggerSource,
  MemoryContentType,
  UserMemoryItem,
  MemoryCommandParseResult,
  MemoryCommand,
  SaveUserMemoryRequest,
  MemoryOperationFeedback,
  UserMemoryManagerConfig
} from '../types/MemoryTypes';
import { AppStorage } from './AppStorage';
import { Logger } from './Logger';
import { VectorEmbeddingService } from '../services/VectorEmbeddingService';

export interface MemoryItemWithoutId {
  title: string;
  content: string;
  tags: string[];
  category: MemoryCategory;
  importance: MemoryImportance;
  isActive: boolean;
  createdAt: number;
  updatedAt: number;
  usageCount: number;
  lastUsedAt: number;
}

// å…³é”®è¯æœç´¢ç»“æœæ¥å£
export interface KeywordSearchResult {
  memory: MemoryFragment;
  score: number;
}

/**
 * è®°å¿†ç®¡ç†å™¨ - è´Ÿè´£ç”¨æˆ·è®°å¿†ç¢ç‰‡çš„ç®¡ç†
 */
export class MemoryManager {
  private static instance: MemoryManager | null = null;
  private readonly MEMORY_STORAGE_KEY = 'user_memories';
  private readonly MEMORY_CONFIG_KEY = 'memory_injection_config';
  private readonly MEMORY_STATS_KEY = 'memory_stats_cache';
  private memoryStatsListeners: Array<(stats: MemoryStats) => void> = [];
  private userMemoryConfig: UserMemoryManagerConfig;
  private readonly supportedCommands: MemoryCommand[];

  private constructor() {
    // åˆå§‹åŒ–ç”¨æˆ·è®°å¿†é…ç½®
    this.userMemoryConfig = {
      autoGenerateTitle: true,
      maxTitleLength: 50,
      defaultCategory: MemoryCategory.CUSTOM,
      defaultImportance: MemoryImportance.MEDIUM,
      enableTagSuggestion: true,
      maxRecentMemories: 20,
      enableExportImport: true
    };

    // åˆå§‹åŒ–æ”¯æŒçš„è®°å¿†æŒ‡ä»¤
    this.supportedCommands = [
      {
        trigger: 'è®°ä½',
        pattern: /^è®°ä½[:ï¼š]\s*(.+)$/i,
        description: 'è®°ä½æŒ‡å®šå†…å®¹',
        example: 'è®°ä½ï¼šæˆ‘å–œæ¬¢å–æ‹¿é“å’–å•¡'
      },
      {
        trigger: 'è®°ä¸‹',
        pattern: /^è®°ä¸‹[:ï¼š]\s*(.+)$/i,
        description: 'è®°ä¸‹æŒ‡å®šå†…å®¹',
        example: 'è®°ä¸‹ï¼šæˆ‘çš„ç”Ÿæ—¥æ˜¯3æœˆ15æ—¥'
      },
      {
        trigger: 'ä¿å­˜',
        pattern: /^ä¿å­˜[:ï¼š]\s*(.+)$/i,
        description: 'ä¿å­˜æŒ‡å®šå†…å®¹åˆ°è®°å¿†',
        example: 'ä¿å­˜ï¼šæˆ‘åœ¨å­—èŠ‚è·³åŠ¨å·¥ä½œ'
      },
      {
        trigger: 'è®°å½•',
        pattern: /^è®°å½•[:ï¼š]\s*(.+)$/i,
        description: 'è®°å½•æŒ‡å®šå†…å®¹',
        example: 'è®°å½•ï¼šæˆ‘å–œæ¬¢å‘¨æœ«å»çˆ¬å±±'
      }
    ];

    // åˆå§‹åŒ–å‘é‡åŒ–æœåŠ¡
    this.initializeVectorService();
  }

  /**
   * åˆå§‹åŒ–å‘é‡åŒ–æœåŠ¡
   */
  private async initializeVectorService(): Promise<void> {
    try {
      const vectorService = VectorEmbeddingService.getInstance();
      const initialized = await vectorService.initialize();
      if (!initialized) {
        Logger.warn('MemoryManager', 'å‘é‡åŒ–æœåŠ¡åˆå§‹åŒ–å¤±è´¥ï¼Œå°†ä½¿ç”¨å…³é”®è¯æœç´¢');
      } else {
        Logger.info('MemoryManager', 'å‘é‡åŒ–æœåŠ¡åˆå§‹åŒ–æˆåŠŸ');
      }
    } catch (error) {
      Logger.warn('MemoryManager', `å‘é‡åŒ–æœåŠ¡åˆå§‹åŒ–å¼‚å¸¸: ${error}`);
    }
  }

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  static getInstance(): MemoryManager {
    if (!MemoryManager.instance) {
      MemoryManager.instance = new MemoryManager();
    }
    return MemoryManager.instance;
  }

  /**
   * ç”Ÿæˆå”¯ä¸€ID
   */
  private generateId(): string {
    return `memory_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * è·å–æ‰€æœ‰è®°å¿†ç¢ç‰‡
   */
  async getAllMemories(): Promise<MemoryFragment[]> {
    try {
      const storage = await AppStorage.getStorageAsync();
      const jsonStr = await storage.get(this.MEMORY_STORAGE_KEY, '[]');
      const memories = JSON.parse(jsonStr as string) as MemoryFragment[];
      Logger.debug('MemoryManager', `è·å–åˆ° ${memories.length} ä¸ªè®°å¿†ç¢ç‰‡`);
      return memories;
    } catch (error) {
      Logger.error('MemoryManager', `è·å–è®°å¿†ç¢ç‰‡å¤±è´¥: ${error}`);
      return [];
    }
  }

  /**
   * åˆ›å»ºæ–°çš„è®°å¿†ç¢ç‰‡
   */
  async createMemory(request: CreateMemoryRequest): Promise<MemoryOperationResult> {
    try {
      if (!request.content || !request.content.trim()) {
        return {
          success: false,
          message: 'è®°å¿†å†…å®¹ä¸èƒ½ä¸ºç©º'
        };
      }

      const now = Date.now();

      // ç”Ÿæˆå‘é‡åµŒå…¥
      const memoryId: string = this.generateId();
      let vector: number[] | undefined = undefined;
      try {
        Logger.info('MemoryManager', `å¼€å§‹ä¸ºè®°å¿†ç”Ÿæˆå‘é‡ - å†…å®¹: "${request.content.trim().substring(0, 100)}${request.content.trim().length > 100 ? '...' : ''}"`);
        const embeddingResult = await VectorEmbeddingService.getInstance().generateEmbedding(request.content.trim());
        if (embeddingResult !== null) {
          vector = embeddingResult;
          Logger.info('MemoryManager', `è®°å¿†å‘é‡ç”ŸæˆæˆåŠŸ - ID: ${memoryId}, ç»´åº¦: ${vector.length}`);
          Logger.info('MemoryManager', `å‘é‡å‰10ä¸ªå€¼: [${vector.slice(0, 10).map(v => v.toFixed(4)).join(', ')}]`);
        } else {
          Logger.warn('MemoryManager', `å‘é‡ç”Ÿæˆè¿”å›nullï¼Œå°†ä¿å­˜ä¸ºæ— å‘é‡è®°å¿†`);
        }
      } catch (error) {
        Logger.error('MemoryManager', `ç”Ÿæˆå‘é‡å¤±è´¥ï¼Œå°†ä¿å­˜ä¸ºæ— å‘é‡è®°å¿†: ${error}`);
        Logger.info('MemoryManager', `è®°å¿†å°†ä¿å­˜ä¸ºçº¯æ–‡æœ¬æ¨¡å¼ï¼Œæ— å‘é‡ä¿¡æ¯`);
        // å‘é‡ç”Ÿæˆå¤±è´¥æ—¶ç»§ç»­ä¿å­˜ï¼Œåªæ˜¯æ²¡æœ‰å‘é‡
      }

      const memory: MemoryFragment = {
        id: memoryId,
        content: request.content.trim(),
        tags: request.tags || [],
        category: request.category || MemoryCategory.CUSTOM,
        importance: request.importance || MemoryImportance.MEDIUM,
        isActive: request.isActive !== undefined ? request.isActive : true,
        createdAt: now,
        updatedAt: now,
        usageCount: 0,
        lastUsedAt: 0,
        vector: vector
      };

      const memories = await this.getAllMemories();
      memories.push(memory);

      const storage = await AppStorage.getStorageAsync();
      await storage.put(this.MEMORY_STORAGE_KEY, JSON.stringify(memories));
      await storage.flush();

      // æ›´æ–°ç»Ÿè®¡ç¼“å­˜
      await this.updateMemoryStatsCache();

      Logger.info('MemoryManager', `åˆ›å»ºè®°å¿†ç¢ç‰‡æˆåŠŸ: ${memory.id}`);
      return {
        success: true,
        message: 'è®°å¿†ç¢ç‰‡åˆ›å»ºæˆåŠŸ',
        data: memory
      };

    } catch (error) {
      Logger.error('MemoryManager', `åˆ›å»ºè®°å¿†ç¢ç‰‡å¤±è´¥: ${error}`);
      return {
        success: false,
        message: `åˆ›å»ºè®°å¿†ç¢ç‰‡å¤±è´¥: ${error}`
      };
    }
  }

  /**
   * æ›´æ–°è®°å¿†ç¢ç‰‡
   */
  async updateMemory(id: string, request: UpdateMemoryRequest): Promise<MemoryOperationResult> {
    try {
      const memories = await this.getAllMemories();
      const index = memories.findIndex(m => m.id === id);

      if (index === -1) {
        return {
          success: false,
          message: 'è®°å¿†ç¢ç‰‡ä¸å­˜åœ¨'
        };
      }

      const memory = memories[index];

      // æ›´æ–°å­—æ®µ
      if (request.content !== undefined) {
        if (!request.content.trim()) {
          return {
            success: false,
            message: 'è®°å¿†å†…å®¹ä¸èƒ½ä¸ºç©º'
          };
        }
        memory.content = request.content.trim();

        // å†…å®¹æ›´æ–°æ—¶é‡æ–°ç”Ÿæˆå‘é‡
        try {
          Logger.info('MemoryManager', `å†…å®¹æ›´æ–°ï¼Œé‡æ–°ç”Ÿæˆå‘é‡ - ID: ${id}`);
          Logger.info('MemoryManager', `æ–°å†…å®¹: "${memory.content.substring(0, 100)}${memory.content.length > 100 ? '...' : ''}"`);
          const vector = await VectorEmbeddingService.getInstance().generateEmbedding(memory.content);
          if (vector) {
            memory.vector = vector;
            Logger.info('MemoryManager', `è®°å¿†æ›´æ–°åå‘é‡é‡æ–°ç”ŸæˆæˆåŠŸ - ID: ${id}, ç»´åº¦: ${vector.length}`);
            Logger.info('MemoryManager', `æ–°å‘é‡å‰10ä¸ªå€¼: [${vector.slice(0, 10).map(v => v.toFixed(4)).join(', ')}]`);
          } else {
            Logger.warn('MemoryManager', `æ›´æ–°åå‘é‡ç”Ÿæˆè¿”å›nullï¼Œä¿ç•™åŸå‘é‡`);
          }
        } catch (error) {
          Logger.error('MemoryManager', `é‡æ–°ç”Ÿæˆå‘é‡å¤±è´¥ï¼Œä¿ç•™åŸå‘é‡æˆ–è®¾ä¸ºæ— å‘é‡: ${error}`);
          Logger.info('MemoryManager', `ä¿ç•™åŸå‘é‡çŠ¶æ€æˆ–è®¾ä¸ºæ— å‘é‡`);
          // å‘é‡ç”Ÿæˆå¤±è´¥æ—¶ä¿ç•™åŸvectoræˆ–è®¾ä¸ºundefined
        }
      }

      if (request.tags !== undefined) {
        memory.tags = request.tags;
      }

      if (request.category !== undefined) {
        memory.category = request.category;
      }

      if (request.importance !== undefined) {
        memory.importance = request.importance;
      }

      if (request.isActive !== undefined) {
        memory.isActive = request.isActive;
      }

      memory.updatedAt = Date.now();

      const storage = await AppStorage.getStorageAsync();
      await storage.put(this.MEMORY_STORAGE_KEY, JSON.stringify(memories));
      await storage.flush();

      Logger.info('MemoryManager', `æ›´æ–°è®°å¿†ç¢ç‰‡æˆåŠŸ: ${id}`);
      return {
        success: true,
        message: 'è®°å¿†ç¢ç‰‡æ›´æ–°æˆåŠŸ',
        data: memory
      };

    } catch (error) {
      Logger.error('MemoryManager', `æ›´æ–°è®°å¿†ç¢ç‰‡å¤±è´¥: ${error}`);
      return {
        success: false,
        message: `æ›´æ–°è®°å¿†ç¢ç‰‡å¤±è´¥: ${error}`
      };
    }
  }

  /**
   * åˆ é™¤è®°å¿†ç¢ç‰‡
   */
  async deleteMemory(id: string): Promise<MemoryOperationResult> {
    try {
      const memories = await this.getAllMemories();
      const index = memories.findIndex(m => m.id === id);

      if (index === -1) {
        return {
          success: false,
          message: 'è®°å¿†ç¢ç‰‡ä¸å­˜åœ¨'
        };
      }

      memories.splice(index, 1);
      const storage = await AppStorage.getStorageAsync();
      await storage.put(this.MEMORY_STORAGE_KEY, JSON.stringify(memories));
      await storage.flush();

      // æ›´æ–°ç»Ÿè®¡ç¼“å­˜
      await this.updateMemoryStatsCache();

      Logger.info('MemoryManager', `åˆ é™¤è®°å¿†ç¢ç‰‡æˆåŠŸ: ${id}`);
      return {
        success: true,
        message: 'è®°å¿†ç¢ç‰‡åˆ é™¤æˆåŠŸ'
      };

    } catch (error) {
      Logger.error('MemoryManager', `åˆ é™¤è®°å¿†ç¢ç‰‡å¤±è´¥: ${error}`);
      return {
        success: false,
        message: `åˆ é™¤è®°å¿†ç¢ç‰‡å¤±è´¥: ${error}`
      };
    }
  }

  /**
   * è·å–å•ä¸ªè®°å¿†ç¢ç‰‡
   */
  async getMemory(id: string): Promise<MemoryFragment | null> {
    try {
      const memories = await this.getAllMemories();
      const memory = memories.find(m => m.id === id);
      return memory || null;
    } catch (error) {
      Logger.error('MemoryManager', `è·å–è®°å¿†ç¢ç‰‡å¤±è´¥: ${error}`);
      return null;
    }
  }

  /**
   * è·å–æ¿€æ´»çš„è®°å¿†ç¢ç‰‡ï¼ˆç”¨äºæ³¨å…¥åˆ°å¯¹è¯ä¸­ï¼‰
   */
  async getActiveMemories(): Promise<MemoryFragment[]> {
    try {
      const memories = await this.getAllMemories();
      const activeMemories = memories.filter(m => m.isActive);

      // æŒ‰é‡è¦æ€§å’Œä½¿ç”¨é¢‘ç‡æ’åº
      activeMemories.sort((a, b) => {
        // é¦–å…ˆæŒ‰é‡è¦æ€§æ’åº
        let aWeight = 0;
        let bWeight = 0;

        // è®¾ç½®açš„æƒé‡
        if (a.importance === MemoryImportance.CRITICAL) aWeight = 4;
        else if (a.importance === MemoryImportance.HIGH) aWeight = 3;
        else if (a.importance === MemoryImportance.MEDIUM) aWeight = 2;
        else if (a.importance === MemoryImportance.LOW) aWeight = 1;

        // è®¾ç½®bçš„æƒé‡
        if (b.importance === MemoryImportance.CRITICAL) bWeight = 4;
        else if (b.importance === MemoryImportance.HIGH) bWeight = 3;
        else if (b.importance === MemoryImportance.MEDIUM) bWeight = 2;
        else if (b.importance === MemoryImportance.LOW) bWeight = 1;

        if (aWeight !== bWeight) {
          return bWeight - aWeight; // é‡è¦æ€§é«˜çš„åœ¨å‰
        }

        // é‡è¦æ€§ç›¸åŒæ—¶ï¼ŒæŒ‰ä½¿ç”¨é¢‘ç‡æ’åº
        if (a.usageCount !== b.usageCount) {
          return b.usageCount - a.usageCount; // ä½¿ç”¨é¢‘ç‡é«˜çš„åœ¨å‰
        }

        // æœ€åæŒ‰æ›´æ–°æ—¶é—´æ’åº
        return b.updatedAt - a.updatedAt; // æœ€è¿‘æ›´æ–°çš„åœ¨å‰
      });

      Logger.debug('MemoryManager', `è·å–åˆ° ${activeMemories.length} ä¸ªæ¿€æ´»çš„è®°å¿†ç¢ç‰‡`);
      return activeMemories;
    } catch (error) {
      Logger.error('MemoryManager', `è·å–æ¿€æ´»è®°å¿†ç¢ç‰‡å¤±è´¥: ${error}`);
      return [];
    }
  }

  /**
   * æœç´¢è®°å¿†ç¢ç‰‡ - æ”¯æŒå‘é‡æœç´¢å’Œå…³é”®è¯æœç´¢
   */
  async searchMemories(semanticQuery: string, keywords: string): Promise<MemoryFragment[]> {
    try {
      if (!semanticQuery?.trim() && !keywords?.trim()) {
        return await this.getAllMemories();
      }

      const memories = await this.getAllMemories();
      const vectorService = VectorEmbeddingService.getInstance();
      const config = vectorService.getConfig();

      // 1. Vector Search
      let vectorResults: VectorSearchResult[] = [];
      if (semanticQuery?.trim()) {
        try {
          const queryVector = await vectorService.generateEmbedding(semanticQuery);
          if (queryVector) {
            Logger.info('MemoryManager', `ç”ŸæˆæŸ¥è¯¢å‘é‡æˆåŠŸï¼Œå¼€å§‹å‘é‡æœç´¢ï¼Œç»´åº¦: ${queryVector.length}`);
            const memoriesWithVectors = memories.filter(m => m.vector && m.vector.length > 0);
            const tempVectorResults: VectorSearchResult[] = memoriesWithVectors
              .map(memory => {
                const vectorResult: VectorSearchResult = {
                  memory: memory,
                  similarity: vectorService.calculateCosineSimilarity(queryVector, memory.vector!)
                };
                return vectorResult;
              });
            vectorResults = tempVectorResults.filter(result => result.similarity >= config.minSimilarity);

            // è¾“å‡ºè¯¦ç»†çš„ç›¸ä¼¼åº¦è°ƒè¯•ä¿¡æ¯
            Logger.info('MemoryManager', `å‘é‡æœç´¢é˜ˆå€¼: ${config.minSimilarity}, åŸå§‹å€™é€‰: ${tempVectorResults.length} ä¸ª, è¿‡æ»¤å: ${vectorResults.length} ä¸ª`);
            if (vectorResults.length > 0) {
              Logger.info('MemoryManager', `å€™é€‰ç»“æœç›¸ä¼¼åº¦åˆ†æ•°: ${vectorResults.map(r => `${r.memory.content.substring(0, 20)}...(${r.similarity.toFixed(3)})`).join(', ')}`);
            }
            if (tempVectorResults.length > vectorResults.length) {
              const filteredResults = tempVectorResults.filter(result => result.similarity < config.minSimilarity);
              Logger.info('MemoryManager', `è¢«è¿‡æ»¤çš„ç»“æœ: ${filteredResults.map(r => `${r.memory.content.substring(0, 20)}...(${r.similarity.toFixed(3)})`).join(', ')}`);
            }
          }
        } catch (error) {
          Logger.warn('MemoryManager', `å‘é‡æœç´¢å¤±è´¥: ${error}`);
        }
      }

      // 2. Keyword Search
      let keywordResults: KeywordSearchResult[] = [];
      if (keywords?.trim()) {
        const expandedKeywords = this.expandKeywords(keywords.toLowerCase().trim());
        const tempKeywordResults: KeywordSearchResult[] = memories.map(memory => {
          const keywordResult: KeywordSearchResult = {
            memory: memory,
            score: this.calculateKeywordScore(memory, expandedKeywords)
          };
          return keywordResult;
        });
        keywordResults = tempKeywordResults.filter(result => result.score > 0);
        Logger.info('MemoryManager', `å…³é”®è¯æœç´¢æ‰¾åˆ° ${keywordResults.length} ä¸ªå€™é€‰ç»“æœ`);
      }

      // 3. Hybrid Merge & Rank
      const resultMap = new Map<string, HybridSearchResult>();

      // Add keyword results to map
      keywordResults.forEach(res => {
        resultMap.set(res.memory.id, {
          memory: res.memory,
          finalScore: res.score * config.keywordWeight,
          keywordScore: res.score,
          vectorScore: 0
        });
      });

      // Add vector results, boosting score if also found by keyword search
      vectorResults.forEach(res => {
        if (resultMap.has(res.memory.id)) {
          const existing = resultMap.get(res.memory.id)!;
          existing.vectorScore = res.similarity;
          existing.finalScore += res.similarity * config.vectorWeight;
        } else {
          resultMap.set(res.memory.id, {
            memory: res.memory,
            finalScore: res.similarity * config.vectorWeight,
            vectorScore: res.similarity,
            keywordScore: 0
          });
        }
      });

      const hybridResults = Array.from(resultMap.values());

      // Sort by final score, then importance, then usage
      hybridResults.sort((a, b) => {
        if (a.finalScore !== b.finalScore) return b.finalScore - a.finalScore;
        const aImportance = this.getImportanceWeight(a.memory.importance);
        const bImportance = this.getImportanceWeight(b.memory.importance);
        if (aImportance !== bImportance) return bImportance - aImportance;
        return b.memory.usageCount - a.memory.usageCount;
      });

      const finalResults = hybridResults.slice(0, config.maxResults).map(result => result.memory);

      Logger.info('MemoryManager', `æ··åˆæœç´¢å®Œæˆï¼Œè¿”å› ${finalResults.length} ä¸ªç»“æœ.`);
      return finalResults;

    } catch (error) {
      Logger.error('MemoryManager', `æœç´¢è®°å¿†ç¢ç‰‡å¤±è´¥: ${error}`);
      return [];
    }
  }

  /**
   * Expands a keyword string into a set of unique search terms using semantic mappings.
   */
  private expandKeywords(keyword: string): string[] {
    const semanticMappings = this.getSemanticMappings();
    let searchTerms = new Set<string>(keyword.split(/\s+/).filter(k => k));

    Object.entries(semanticMappings).forEach((entry: [string, string[]]) => {
      const pattern = entry[0];
      const terms = entry[1];
      if (keyword.includes(pattern)) {
        terms.forEach(term => searchTerms.add(term));
      }
    });
    
    const expanded = Array.from(searchTerms);
    Logger.debug('MemoryManager', `å…³é”®è¯ "${keyword}" æ‰©å±•ä¸º: [${expanded.join(', ')}]`);
    return expanded;
  }

  /**
   * Calculates a score based on how well a memory's content and tags match a set of keywords.
   */
  private calculateKeywordScore(memory: MemoryFragment, keywords: string[]): number {
    const lowerContent = memory.content.toLowerCase();
    const lowerTags = memory.tags.map(tag => tag.toLowerCase());
    let score = 0;

    keywords.forEach(kw => {
      if (lowerContent.includes(kw)) {
        score += 1; // Base score for content match
      }
      if (lowerTags.some(tag => tag.includes(kw))) {
        score += 2; // Higher score for tag match
      }
    });

    // Normalize score - simple normalization for demonstration
    return score > 0 ? Math.min(score / 5, 1.0) : 0;
  }


  /**
   * è¯­ä¹‰æ˜ å°„ï¼šå°†è‡ªç„¶è¯­è¨€é—®é¢˜æ˜ å°„åˆ°ç›¸å…³å…³é”®è¯
   */
  private getSemanticMappings(): Record<string, string[]> {
    return {
      'åå­—': ['åå­—', 'å§“å', 'ç§°å‘¼', 'å«æˆ‘ä»€ä¹ˆ', 'æ€ä¹ˆç§°å‘¼', 'æˆ‘æ˜¯è°'],
      'ä½ å«': ['åå­—', 'å§“å', 'ç§°å‘¼', 'åŠ©æ‰‹', 'ai', 'æœºå™¨äºº'],
      'æˆ‘å«': ['åå­—', 'å§“å', 'ç”¨æˆ·', 'ä¸»äºº'],
      'ç§°å‘¼': ['åå­—', 'å§“å', 'å«æˆ‘ä»€ä¹ˆ', 'æ€ä¹ˆç§°å‘¼'],
      'æˆ‘æ˜¯': ['åå­—', 'å§“å', 'ç”¨æˆ·', 'ä¸»äºº'],
      'ç”¨æˆ·': ['åå­—', 'å§“å', 'ç”¨æˆ·', 'ä¸»äºº', 'ä½ '],
      'åå¥½': ['å–œæ¬¢', 'ä¸å–œæ¬¢', 'åå¥½', 'ä¹ æƒ¯', 'çˆ±å¥½', 'å…´è¶£'],
      'è®¾ç½®': ['é…ç½®', 'è®¾ç½®', 'é€‰é¡¹', 'å‚æ•°', 'åå¥½'],
      'å·¥ä½œ': ['å·¥ä½œ', 'èŒä¸š', 'å…¬å¸', 'èŒä½', 'ä¸“ä¸š'],
      'å­¦ä¹ ': ['å­¦ä¹ ', 'æ•™è‚²', 'å­¦æ ¡', 'ä¸“ä¸š', 'è¯¾ç¨‹'],
      'å®¶åº­': ['å®¶åº­', 'å®¶äºº', 'çˆ¶æ¯', 'å­å¥³', 'é…å¶'],
      'çˆ±å¥½': ['çˆ±å¥½', 'å…´è¶£', 'å–œæ¬¢', 'å¨±ä¹', 'è¿åŠ¨']
    };
  }



  /**
   * è·å–é‡è¦æ€§æƒé‡
   */
  private getImportanceWeight(importance: string): number {
    switch (importance) {
      case 'critical': return 4;
      case 'high': return 3;
      case 'medium': return 2;
      case 'low': return 1;
      default: return 1;
    }
  }

  /**
   * æŒ‰åˆ†ç±»è·å–è®°å¿†ç¢ç‰‡
   */
  async getMemoriesByCategory(category: MemoryCategory): Promise<MemoryFragment[]> {
    try {
      const memories = await this.getAllMemories();
      const categoryMemories = memories.filter(m => m.category === category);

      Logger.debug('MemoryManager', `åˆ†ç±» ${category} æœ‰ ${categoryMemories.length} ä¸ªè®°å¿†ç¢ç‰‡`);
      return categoryMemories;
    } catch (error) {
      Logger.error('MemoryManager', `æŒ‰åˆ†ç±»è·å–è®°å¿†ç¢ç‰‡å¤±è´¥: ${error}`);
      return [];
    }
  }

  /**
   * è·å–è®°å¿†ç»Ÿè®¡ä¿¡æ¯
   */
  async getMemoryStats(): Promise<MemoryStats> {
    try {
      const memories = await this.getAllMemories();

      const categoryCounts: MemoryCategoryCounts = {
        personal: 0,
        preference: 0,
        work: 0,
        study: 0,
        hobby: 0,
        family: 0,
        health: 0,
        custom: 0
      };

      const importanceCounts: MemoryImportanceCounts = {
        low: 0,
        medium: 0,
        high: 0,
        critical: 0
      };

      let lastUpdated = 0;
      let totalUsageCount = 0;

      memories.forEach(memory => {
        // æ›´æ–°åˆ†ç±»ç»Ÿè®¡
        if (memory.category === MemoryCategory.PERSONAL) categoryCounts.personal++;
        else if (memory.category === MemoryCategory.PREFERENCE) categoryCounts.preference++;
        else if (memory.category === MemoryCategory.WORK) categoryCounts.work++;
        else if (memory.category === MemoryCategory.STUDY) categoryCounts.study++;
        else if (memory.category === MemoryCategory.HOBBY) categoryCounts.hobby++;
        else if (memory.category === MemoryCategory.FAMILY) categoryCounts.family++;
        else if (memory.category === MemoryCategory.HEALTH) categoryCounts.health++;
        else if (memory.category === MemoryCategory.CUSTOM) categoryCounts.custom++;

        // æ›´æ–°é‡è¦æ€§ç»Ÿè®¡
        if (memory.importance === MemoryImportance.LOW) importanceCounts.low++;
        else if (memory.importance === MemoryImportance.MEDIUM) importanceCounts.medium++;
        else if (memory.importance === MemoryImportance.HIGH) importanceCounts.high++;
        else if (memory.importance === MemoryImportance.CRITICAL) importanceCounts.critical++;

        totalUsageCount += memory.usageCount;

        if (memory.updatedAt > lastUpdated) {
          lastUpdated = memory.updatedAt;
        }
      });

      const stats: MemoryStats = {
        totalFragments: memories.length,
        activeFragments: memories.filter(m => m.isActive).length,
        categoryCounts: categoryCounts,
        importanceCounts: importanceCounts,
        lastUpdated: lastUpdated,
        totalUsageCount: totalUsageCount
      };

      return stats;
    } catch (error) {
      Logger.error('MemoryManager', `è·å–è®°å¿†ç»Ÿè®¡å¤±è´¥: ${error}`);
      return {
        totalFragments: 0,
        activeFragments: 0,
        categoryCounts: {
          personal: 0,
          preference: 0,
          work: 0,
          study: 0,
          hobby: 0,
          family: 0,
          health: 0,
          custom: 0
        },
        importanceCounts: {
          low: 0,
          medium: 0,
          high: 0,
          critical: 0
        },
        lastUpdated: 0,
        totalUsageCount: 0
      };
    }
  }

  /**
   * å¢åŠ è®°å¿†ä½¿ç”¨æ¬¡æ•°
   */
  async incrementUsageCount(id: string): Promise<void> {
    try {
      const memories = await this.getAllMemories();
      const memory = memories.find(m => m.id === id);

      if (memory) {
        memory.usageCount++;
        memory.lastUsedAt = Date.now();
        const storage = await AppStorage.getStorageAsync();
      await storage.put(this.MEMORY_STORAGE_KEY, JSON.stringify(memories));
      await storage.flush();
        Logger.debug('MemoryManager', `è®°å¿†ç¢ç‰‡ ${id} ä½¿ç”¨æ¬¡æ•°å¢åŠ è‡³ ${memory.usageCount}`);
      }
    } catch (error) {
      Logger.error('MemoryManager', `å¢åŠ ä½¿ç”¨æ¬¡æ•°å¤±è´¥: ${error}`);
    }
  }

  /**
   * ç”Ÿæˆè®°å¿†æ³¨å…¥æ–‡æœ¬ï¼ˆç”¨äºç³»ç»Ÿæç¤ºè¯ï¼‰
   */
  async generateMemoryInjectionText(): Promise<string> {
    try {
      const activeMemories = await this.getActiveMemories();

      if (activeMemories.length === 0) {
        return '';
      }

      // é™åˆ¶æœ€å¤§æ•°é‡ï¼ˆé¿å…æç¤ºè¯è¿‡é•¿ï¼‰
      const maxMemories = 10;
      const memoriesToUse = activeMemories.slice(0, maxMemories);

      // å¢åŠ ä½¿ç”¨æ¬¡æ•°
      for (const memory of memoriesToUse) {
        await this.incrementUsageCount(memory.id);
      }

      // ç”Ÿæˆæ³¨å…¥æ–‡æœ¬
      const memoryLines = memoriesToUse.map(memory => `- ${memory.content}`);

      const injectionText = `---
è¿™æ˜¯å…³äºç”¨æˆ·çš„ä¸€äº›é‡è¦è®°å¿†ï¼Œè¯·åœ¨å›ç­”æ—¶å‚è€ƒï¼š
${memoryLines.join('\n')}
---`;

      Logger.info('MemoryManager', `ç”Ÿæˆè®°å¿†æ³¨å…¥æ–‡æœ¬ï¼ŒåŒ…å« ${memoriesToUse.length} ä¸ªè®°å¿†ç¢ç‰‡`);
      return injectionText;

    } catch (error) {
      Logger.error('MemoryManager', `ç”Ÿæˆè®°å¿†æ³¨å…¥æ–‡æœ¬å¤±è´¥: ${error}`);
      return '';
    }
  }

  /**
   * åˆ‡æ¢è®°å¿†ç¢ç‰‡çš„æ¿€æ´»çŠ¶æ€
   */
  async toggleMemoryActive(id: string): Promise<MemoryOperationResult> {
    try {
      const memories = await this.getAllMemories();
      const memory = memories.find(m => m.id === id);

      if (!memory) {
        return {
          success: false,
          message: 'è®°å¿†ç¢ç‰‡ä¸å­˜åœ¨'
        };
      }

      memory.isActive = !memory.isActive;
      memory.updatedAt = Date.now();

      const storage = await AppStorage.getStorageAsync();
      await storage.put(this.MEMORY_STORAGE_KEY, JSON.stringify(memories));
      await storage.flush();

      Logger.info('MemoryManager', `è®°å¿†ç¢ç‰‡ ${id} æ¿€æ´»çŠ¶æ€åˆ‡æ¢ä¸º: ${memory.isActive}`);
      return {
        success: true,
        message: `è®°å¿†ç¢ç‰‡å·²${memory.isActive ? 'æ¿€æ´»' : 'åœç”¨'}`,
        data: memory
      };

    } catch (error) {
      Logger.error('MemoryManager', `åˆ‡æ¢è®°å¿†ç¢ç‰‡æ¿€æ´»çŠ¶æ€å¤±è´¥: ${error}`);
      return {
        success: false,
        message: `åˆ‡æ¢æ¿€æ´»çŠ¶æ€å¤±è´¥: ${error}`
      };
    }
  }

  /**
   * æ¸…ç©ºæ‰€æœ‰è®°å¿†ç¢ç‰‡
   */
  async clearAllMemories(): Promise<MemoryOperationResult> {
    try {
      const storage = await AppStorage.getStorageAsync();
      await storage.put(this.MEMORY_STORAGE_KEY, JSON.stringify([]));
      await storage.flush();

      Logger.info('MemoryManager', 'å·²æ¸…ç©ºæ‰€æœ‰è®°å¿†ç¢ç‰‡');
      return {
        success: true,
        message: 'æ‰€æœ‰è®°å¿†ç¢ç‰‡å·²æ¸…ç©º'
      };

    } catch (error) {
      Logger.error('MemoryManager', `æ¸…ç©ºè®°å¿†ç¢ç‰‡å¤±è´¥: ${error}`);
      return {
        success: false,
        message: `æ¸…ç©ºå¤±è´¥: ${error}`
      };
    }
  }

  /**
   * è·å–è®°å¿†é¡¹åˆ—è¡¨ï¼ˆå…¼å®¹MemoryItemæ¥å£ï¼‰
   */
  async getMemoryItems(): Promise<MemoryItem[]> {
    const fragments = await this.getAllMemories();
    return fragments.map(fragment => ({
      id: fragment.id,
      title: `è®°å¿†-${fragment.createdAt}`,
      content: fragment.content,
      tags: fragment.tags,
      category: fragment.category,
      importance: fragment.importance,
      isActive: fragment.isActive,
      createdAt: fragment.createdAt,
      updatedAt: fragment.updatedAt,
      usageCount: fragment.usageCount,
      lastUsedAt: fragment.lastUsedAt
    } as MemoryItem));
  }

  /**
   * æ·»åŠ è®°å¿†é¡¹ï¼ˆå…¼å®¹MemoryItemæ¥å£ï¼‰
   */
  async addMemoryItem(item: MemoryItemWithoutId): Promise<MemoryItem> {
    const request: CreateMemoryRequest = {
      content: item.content,
      tags: item.tags,
      category: item.category,
      importance: item.importance,
      isActive: item.isActive
    };

    const result = await this.createMemory(request);
    if (result.success && result.data) {
      const fragment = Array.isArray(result.data) ? result.data[0] : result.data;
      return {
        id: fragment.id,
        title: `è®°å¿†-${fragment.createdAt}`,
        content: fragment.content,
        tags: fragment.tags,
        category: fragment.category,
        importance: fragment.importance,
        isActive: fragment.isActive,
        createdAt: fragment.createdAt,
        updatedAt: fragment.updatedAt,
        usageCount: fragment.usageCount,
        lastUsedAt: fragment.lastUsedAt
      } as MemoryItem;
    }
    throw new Error(result.message || 'æ·»åŠ è®°å¿†å¤±è´¥');
  }

  /**
   * æ›´æ–°è®°å¿†é¡¹ï¼ˆå…¼å®¹MemoryItemæ¥å£ï¼‰
   */
  async updateMemoryItem(id: string, item: MemoryItemWithoutId): Promise<MemoryItem> {
    const request: UpdateMemoryRequest = {
      content: item.content,
      tags: item.tags,
      category: item.category,
      importance: item.importance,
      isActive: item.isActive
    };

    Logger.debug('MemoryManager', `updateMemoryItemè°ƒç”¨ï¼ŒID: ${id}, å†…å®¹é•¿åº¦: ${item.content.length}`);
    const result = await this.updateMemory(id, request);
    if (result.success && result.data) {
      const fragment = Array.isArray(result.data) ? result.data[0] : result.data;
      // ğŸ”§ ä¿®å¤ï¼šä½¿ç”¨åŠ¨æ€ç”Ÿæˆçš„titleè€Œä¸æ˜¯ä¼ å…¥çš„title
      const generatedTitle = `è®°å¿†-${fragment.createdAt}`;
      Logger.debug('MemoryManager', `updateMemoryItemæˆåŠŸï¼Œç”Ÿæˆtitle: ${generatedTitle}`);
      return {
        id: fragment.id,
        title: generatedTitle, // ä½¿ç”¨åŠ¨æ€ç”Ÿæˆçš„title
        content: fragment.content,
        tags: fragment.tags,
        category: fragment.category,
        importance: fragment.importance,
        isActive: fragment.isActive,
        createdAt: fragment.createdAt,
        updatedAt: fragment.updatedAt,
        usageCount: fragment.usageCount,
        lastUsedAt: fragment.lastUsedAt
      } as MemoryItem;
    }
    Logger.error('MemoryManager', `updateMemoryItemå¤±è´¥: ${result.message}`);
    throw new Error(result.message || 'æ›´æ–°è®°å¿†å¤±è´¥');
  }

  /**
   * åˆ é™¤è®°å¿†é¡¹ï¼ˆå…¼å®¹MemoryItemæ¥å£ï¼‰
   */
  async deleteMemoryItem(id: string): Promise<boolean> {
    const result = await this.deleteMemory(id);
    return result.success;
  }

  /**
   * ä¿å­˜è®°å¿†ç»Ÿè®¡æ•°æ®åˆ°ç¼“å­˜
   */
  private async saveMemoryStatsCache(stats: MemoryStats): Promise<void> {
    try {
      const storage = await AppStorage.getStorageAsync();
      await storage.put(this.MEMORY_STATS_KEY, JSON.stringify(stats));
      await storage.flush();
      Logger.debug('MemoryManager', `è®°å¿†ç»Ÿè®¡æ•°æ®å·²ç¼“å­˜: æ€»è®¡${stats.totalFragments}ä¸ªï¼Œæ¿€æ´»${stats.activeFragments}ä¸ª`);
    } catch (error) {
      Logger.error('MemoryManager', `ä¿å­˜è®°å¿†ç»Ÿè®¡ç¼“å­˜å¤±è´¥: ${error}`);
    }
  }

  /**
   * ä»ç¼“å­˜è·å–è®°å¿†ç»Ÿè®¡æ•°æ®
   */
  async getCachedMemoryStats(): Promise<MemoryStats | null> {
    try {
      const storage = await AppStorage.getStorageAsync();
      const jsonStr = await storage.get(this.MEMORY_STATS_KEY, '');

      if (!jsonStr) {
        Logger.debug('MemoryManager', 'æœªæ‰¾åˆ°è®°å¿†ç»Ÿè®¡ç¼“å­˜');
        return null;
      }

      const stats = JSON.parse(jsonStr as string) as MemoryStats;
      Logger.debug('MemoryManager', `ä»ç¼“å­˜è·å–è®°å¿†ç»Ÿè®¡: æ€»è®¡${stats.totalFragments}ä¸ªï¼Œæ¿€æ´»${stats.activeFragments}ä¸ª`);
      return stats;
    } catch (error) {
      Logger.error('MemoryManager', `è·å–è®°å¿†ç»Ÿè®¡ç¼“å­˜å¤±è´¥: ${error}`);
      return null;
    }
  }

  /**
   * æ›´æ–°è®°å¿†ç»Ÿè®¡ç¼“å­˜ï¼ˆåœ¨æ•°æ®å˜æ›´æ—¶è°ƒç”¨ï¼‰
   */
  async updateMemoryStatsCache(): Promise<void> {
    try {
      const stats = await this.getMemoryStats();
      await this.saveMemoryStatsCache(stats);
      Logger.info('MemoryManager', `è®°å¿†ç»Ÿè®¡ç¼“å­˜å·²æ›´æ–°: æ€»è®¡${stats.totalFragments}ä¸ªï¼Œæ¿€æ´»${stats.activeFragments}ä¸ª`);

      // é€šçŸ¥æ‰€æœ‰ç›‘å¬å™¨
      this.notifyMemoryStatsListeners(stats);
    } catch (error) {
      Logger.error('MemoryManager', `æ›´æ–°è®°å¿†ç»Ÿè®¡ç¼“å­˜å¤±è´¥: ${error}`);
    }
  }

  /**
   * æ·»åŠ è®°å¿†ç»Ÿè®¡å˜æ›´ç›‘å¬å™¨
   */
  addMemoryStatsListener(listener: (stats: MemoryStats) => void): void {
    this.memoryStatsListeners.push(listener);
    Logger.debug('MemoryManager', `æ·»åŠ è®°å¿†ç»Ÿè®¡ç›‘å¬å™¨ï¼Œå½“å‰ç›‘å¬å™¨æ•°é‡: ${this.memoryStatsListeners.length}`);
  }

  /**
   * ç§»é™¤è®°å¿†ç»Ÿè®¡å˜æ›´ç›‘å¬å™¨
   */
  removeMemoryStatsListener(listener: (stats: MemoryStats) => void): void {
    const index = this.memoryStatsListeners.indexOf(listener);
    if (index > -1) {
      this.memoryStatsListeners.splice(index, 1);
      Logger.debug('MemoryManager', `ç§»é™¤è®°å¿†ç»Ÿè®¡ç›‘å¬å™¨ï¼Œå½“å‰ç›‘å¬å™¨æ•°é‡: ${this.memoryStatsListeners.length}`);
    }
  }

  /**
   * é€šçŸ¥æ‰€æœ‰è®°å¿†ç»Ÿè®¡ç›‘å¬å™¨
   */
  private notifyMemoryStatsListeners(stats: MemoryStats): void {
    Logger.debug('MemoryManager', `é€šçŸ¥ ${this.memoryStatsListeners.length} ä¸ªè®°å¿†ç»Ÿè®¡ç›‘å¬å™¨`);
    this.memoryStatsListeners.forEach(listener => {
      try {
        listener(stats);
      } catch (error) {
        Logger.error('MemoryManager', `è®°å¿†ç»Ÿè®¡ç›‘å¬å™¨æ‰§è¡Œå¤±è´¥: ${error}`);
      }
    });
  }

  /**
   * è¿ç§»ç°æœ‰è®°å¿†æ•°æ®ï¼Œä¸ºæ²¡æœ‰å‘é‡çš„è®°å¿†ç”Ÿæˆå‘é‡
   */
  async migrateMemoriesToVectors(): Promise<MemoryOperationResult> {
    try {
      Logger.info('MemoryManager', 'å¼€å§‹è¿ç§»è®°å¿†æ•°æ®åˆ°å‘é‡æ ¼å¼...');

      const memories = await this.getAllMemories();
      const vectorService = VectorEmbeddingService.getInstance();

      // æ£€æŸ¥æ˜¯å¦éœ€è¦è¿ç§»
      const memoriesWithoutVectors = memories.filter(memory => !memory.vector || memory.vector.length === 0);

      if (memoriesWithoutVectors.length === 0) {
        Logger.info('MemoryManager', 'æ‰€æœ‰è®°å¿†å·²æœ‰å‘é‡ï¼Œæ— éœ€è¿ç§»');
        return {
          success: true,
          message: 'æ‰€æœ‰è®°å¿†å·²æœ‰å‘é‡ï¼Œæ— éœ€è¿ç§»'
        };
      }

      Logger.info('MemoryManager', `å‘ç° ${memoriesWithoutVectors.length} ä¸ªè®°å¿†éœ€è¦å‘é‡è¿ç§»`);

      // é™åˆ¶æ¯æ¬¡è¿ç§»çš„æ•°é‡ï¼Œé¿å…APIé™åˆ¶
      const batchSize = 50;
      let successCount = 0;
      let failCount = 0;

      for (let i = 0; i < memoriesWithoutVectors.length; i += batchSize) {
        const batch = memoriesWithoutVectors.slice(i, i + batchSize);
        Logger.info('MemoryManager', `æ­£åœ¨å¤„ç†ç¬¬ ${Math.floor(i / batchSize) + 1} æ‰¹ï¼Œå…± ${batch.length} ä¸ªè®°å¿†`);

        // ä¸ºè¿™ä¸€æ‰¹è®°å¿†ç”Ÿæˆå‘é‡
        const texts: string[] = batch.map(memory => memory.content);
        const embeddings: (number[] | null)[] = await vectorService.generateEmbeddings(texts);

        // æ›´æ–°è®°å¿†çš„å‘é‡
        for (let j = 0; j < batch.length; j++) {
          const memory = batch[j];
          const vector = embeddings[j];

          if (vector && vector.length > 0) {
            // æ‰¾åˆ°åŸå§‹è®°å¿†å¹¶æ›´æ–°
            const originalIndex = memories.findIndex(m => m.id === memory.id);
            if (originalIndex !== -1) {
              memories[originalIndex].vector = vector;
              memories[originalIndex].updatedAt = Date.now();
              successCount++;
            }
          } else {
            failCount++;
            Logger.warn('MemoryManager', `è®°å¿† "${memory.content.substring(0, 50)}..." å‘é‡ç”Ÿæˆå¤±è´¥`);
          }
        }

        // æ¯æ‰¹å®Œæˆåä¿å­˜ä¸€æ¬¡
        const storage = AppStorage.getPreferences();
        await storage.put(this.MEMORY_STORAGE_KEY, JSON.stringify(memories));
        await storage.flush();

        // æ·»åŠ å»¶è¿Ÿé¿å…APIé™åˆ¶
        if (i + batchSize < memoriesWithoutVectors.length) {
          await new Promise<void>(resolve => setTimeout(resolve, 1000));
        }
      }

      Logger.info('MemoryManager',
        `å‘é‡è¿ç§»å®Œæˆ: æˆåŠŸ ${successCount} ä¸ªï¼Œå¤±è´¥ ${failCount} ä¸ª`
      );

      // æ›´æ–°ç»Ÿè®¡ç¼“å­˜
      await this.updateMemoryStatsCache();

      return {
        success: true,
        message: `å‘é‡è¿ç§»å®Œæˆ: æˆåŠŸ ${successCount} ä¸ªï¼Œå¤±è´¥ ${failCount} ä¸ª`,
        data: memories
      };

    } catch (error) {
      Logger.error('MemoryManager', `å‘é‡è¿ç§»å¤±è´¥: ${error}`);
      return {
        success: false,
        message: `å‘é‡è¿ç§»å¤±è´¥: ${error}`
      };
    }
  }

  
  /**
   * è·å–å‘é‡è¿ç§»çŠ¶æ€
   */
  async getVectorMigrationStatus(): Promise<VectorMigrationStatus> {
    try {
      const memories = await this.getAllMemories();
      const memoriesWithVectors = memories.filter(memory => memory.vector && memory.vector.length > 0).length;
      const memoriesWithoutVectors = memories.length - memoriesWithVectors;

      const status: VectorMigrationStatus = {
        totalMemories: memories.length,
        memoriesWithVectors: memoriesWithVectors,
        memoriesWithoutVectors: memoriesWithoutVectors,
        migrationNeeded: memoriesWithoutVectors > 0
      };
      return status;
    } catch (error) {
      Logger.error('MemoryManager', `è·å–å‘é‡è¿ç§»çŠ¶æ€å¤±è´¥: ${error}`);
      const errorStatus: VectorMigrationStatus = {
        totalMemories: 0,
        memoriesWithVectors: 0,
        memoriesWithoutVectors: 0,
        migrationNeeded: false
      };
      return errorStatus;
    }
  }

  /**
   * è®°å½•æ‰€æœ‰è®°å¿†çš„å‘é‡ä¿¡æ¯åˆ°æ—¥å¿—
   */
  async logAllMemoryVectors(): Promise<void> {
    try {
      const memories = await this.getAllMemories();
      Logger.info('MemoryManager', `========== å¼€å§‹è®°å½•æ‰€æœ‰è®°å¿†å‘é‡ä¿¡æ¯ ==========`);
      Logger.info('MemoryManager', `æ€»è®°å¿†æ•°é‡: ${memories.length}`);

      const memoriesWithVectors = memories.filter(memory => memory.vector && memory.vector.length > 0);
      const memoriesWithoutVectors = memories.filter(memory => !memory.vector || memory.vector.length === 0);

      Logger.info('MemoryManager', `æœ‰å‘é‡çš„è®°å¿†: ${memoriesWithVectors.length}`);
      Logger.info('MemoryManager', `æ— å‘é‡çš„è®°å¿†: ${memoriesWithoutVectors.length}`);

      // è®°å½•æœ‰å‘é‡çš„è®°å¿†è¯¦æƒ…
      memoriesWithVectors.forEach((memory, index) => {
        Logger.info('MemoryManager', `--- è®°å¿† ${index + 1} ---`);
        Logger.info('MemoryManager', `ID: ${memory.id}`);
        Logger.info('MemoryManager', `å†…å®¹: "${memory.content.substring(0, 50)}${memory.content.length > 50 ? '...' : ''}"`);
        Logger.info('MemoryManager', `å‘é‡ç»´åº¦: ${memory.vector!.length}`);
        Logger.info('MemoryManager', `å‘é‡å‰10ä¸ªå€¼: [${memory.vector!.slice(0, 10).map(v => v.toFixed(4)).join(', ')}]`);
        Logger.info('MemoryManager', `å‘é‡ç»Ÿè®¡ - æœ€å°å€¼: ${Math.min(...memory.vector!).toFixed(4)}, æœ€å¤§å€¼: ${Math.max(...memory.vector!).toFixed(4)}`);
        Logger.info('MemoryManager', `å‘é‡ç»Ÿè®¡ - å¹³å‡å€¼: ${(memory.vector!.reduce((a, b) => a + b, 0) / memory.vector!.length).toFixed(4)}`);
        Logger.info('MemoryManager', `åˆ›å»ºæ—¶é—´: ${new Date(memory.createdAt).toLocaleString()}`);
        Logger.info('MemoryManager', `æ›´æ–°æ—¶é—´: ${new Date(memory.updatedAt).toLocaleString()}`);
        Logger.info('MemoryManager', `ä½¿ç”¨æ¬¡æ•°: ${memory.usageCount}`);
        Logger.info('MemoryManager', `åˆ†ç±»: ${memory.category}, é‡è¦æ€§: ${memory.importance}`);
      });

      // è®°å½•æ— å‘é‡çš„è®°å¿†
      if (memoriesWithoutVectors.length > 0) {
        Logger.info('MemoryManager', `--- æ— å‘é‡è®°å¿†åˆ—è¡¨ ---`);
        memoriesWithoutVectors.forEach((memory, index) => {
          Logger.info('MemoryManager', `${index + 1}. ID: ${memory.id}, å†…å®¹: "${memory.content.substring(0, 30)}${memory.content.length > 30 ? '...' : ''}"`);
        });
      }

      Logger.info('MemoryManager', `========== è®°å¿†å‘é‡ä¿¡æ¯è®°å½•å®Œæˆ ==========`);
    } catch (error) {
      Logger.error('MemoryManager', `è®°å½•è®°å¿†å‘é‡ä¿¡æ¯å¤±è´¥: ${error}`);
    }
  }

  /**
   * è·å–æŒ‡å®šè®°å¿†çš„å‘é‡ä¿¡æ¯
   */
  async logMemoryVector(id: string): Promise<void> {
    try {
      const memory = await this.getMemory(id);
      if (!memory) {
        Logger.warn('MemoryManager', `æœªæ‰¾åˆ°IDä¸º ${id} çš„è®°å¿†`);
        return;
      }

      Logger.info('MemoryManager', `========== è®°å¿†å‘é‡ä¿¡æ¯ ==========`);
      Logger.info('MemoryManager', `ID: ${memory.id}`);
      Logger.info('MemoryManager', `å†…å®¹: "${memory.content}"`);

      if (memory.vector && memory.vector.length > 0) {
        Logger.info('MemoryManager', `å‘é‡çŠ¶æ€: æœ‰å‘é‡`);
        Logger.info('MemoryManager', `å‘é‡ç»´åº¦: ${memory.vector.length}`);
        Logger.info('MemoryManager', `å®Œæ•´å‘é‡: [${memory.vector.map(v => v.toFixed(4)).join(', ')}]`);
        Logger.info('MemoryManager', `å‘é‡å‰10ä¸ªå€¼: [${memory.vector.slice(0, 10).map(v => v.toFixed(4)).join(', ')}]`);
        Logger.info('MemoryManager', `å‘é‡å10ä¸ªå€¼: [${memory.vector.slice(-10).map(v => v.toFixed(4)).join(', ')}]`);
        Logger.info('MemoryManager', `å‘é‡ç»Ÿè®¡ - æœ€å°å€¼: ${Math.min(...memory.vector).toFixed(4)}, æœ€å¤§å€¼: ${Math.max(...memory.vector).toFixed(4)}`);
        Logger.info('MemoryManager', `å‘é‡ç»Ÿè®¡ - å¹³å‡å€¼: ${(memory.vector.reduce((a, b) => a + b, 0) / memory.vector.length).toFixed(4)}`);
        Logger.info('MemoryManager', `å‘é‡ç»Ÿè®¡ - æ ‡å‡†å·®: ${Math.sqrt(memory.vector.reduce((a, b) => a + b * b, 0) / memory.vector.length - Math.pow(memory.vector.reduce((a, b) => a + b, 0) / memory.vector.length, 2)).toFixed(4)}`);
      } else {
        Logger.info('MemoryManager', `å‘é‡çŠ¶æ€: æ— å‘é‡`);
      }

      Logger.info('MemoryManager', `åˆ›å»ºæ—¶é—´: ${new Date(memory.createdAt).toLocaleString()}`);
      Logger.info('MemoryManager', `æ›´æ–°æ—¶é—´: ${new Date(memory.updatedAt).toLocaleString()}`);
      Logger.info('MemoryManager', `ä½¿ç”¨æ¬¡æ•°: ${memory.usageCount}`);
      Logger.info('MemoryManager', `åˆ†ç±»: ${memory.category}, é‡è¦æ€§: ${memory.importance}`);
      Logger.info('MemoryManager', `===============================`);
    } catch (error) {
      Logger.error('MemoryManager', `è·å–è®°å¿†å‘é‡ä¿¡æ¯å¤±è´¥: ${error}`);
    }
  }

  // ====== ç”¨æˆ·ä¸»åŠ¨è§¦å‘è®°å¿†åŠŸèƒ½ ======

  /**
   * è§£æç”¨æˆ·è¾“å…¥ä¸­çš„è®°å¿†æŒ‡ä»¤
   */
  parseMemoryCommand(input: string): MemoryCommandParseResult {
    const trimmedInput = input.trim();

    for (const command of this.supportedCommands) {
      const match = trimmedInput.match(command.pattern);
      if (match && match[1]) {
        const content = match[1].trim();
        const title = this.userMemoryConfig.autoGenerateTitle
          ? this.generateTitle(content)
          : undefined;

        return {
          isMemoryCommand: true,
          command: command.trigger,
          content: content,
          title: title,
          tags: this.userMemoryConfig.enableTagSuggestion ? this.suggestTags(content) : [],
          category: this.inferCategory(content)
        };
      }
    }

    return {
      isMemoryCommand: false,
      command: '',
      content: '',
      title: undefined,
      tags: [],
      category: undefined
    };
  }

  /**
   * ä¿å­˜ç”¨æˆ·ä¸»åŠ¨è§¦å‘çš„è®°å¿†
   */
  async saveUserMemory(request: SaveUserMemoryRequest): Promise<MemoryOperationFeedback> {
    try {
      Logger.info('MemoryManager', `ä¿å­˜ç”¨æˆ·è®°å¿†: æ¥æº=${request.triggerSource}, å†…å®¹="${request.content.substring(0, 50)}..."`);

      // ç”Ÿæˆæ ‡é¢˜
      const title = request.title || (this.userMemoryConfig.autoGenerateTitle
        ? this.generateTitle(request.content)
        : `è®°å¿†-${Date.now()}`);

      // æ¨æ–­å†…å®¹ç±»å‹
      const contentType = request.contentType || this.inferContentType(request.content);

      // åˆ›å»ºè®°å¿†è¯·æ±‚
      const createRequest: CreateMemoryRequest = {
        content: request.content,
        tags: request.tags || (this.userMemoryConfig.enableTagSuggestion ? this.suggestTags(request.content) : []),
        category: request.category || this.userMemoryConfig.defaultCategory,
        importance: request.importance || this.userMemoryConfig.defaultImportance,
        isActive: true
      };

      // ä¿å­˜è®°å¿†
      const result = await this.createMemory(createRequest);

      if (result.success && result.data) {
        const memory = Array.isArray(result.data) ? result.data[0] : result.data;
        Logger.info('MemoryManager', `ç”¨æˆ·è®°å¿†ä¿å­˜æˆåŠŸ: ID=${memory.id}, æ ‡é¢˜="${title}"`);

        return {
          success: true,
          message: `å·²è®°ä½ï¼š${title}`,
          memoryId: memory.id,
          title: title,
          action: 'save'
        };
      } else {
        Logger.error('MemoryManager', `ç”¨æˆ·è®°å¿†ä¿å­˜å¤±è´¥: ${result.message}`);
        return {
          success: false,
          message: `è®°å¿†ä¿å­˜å¤±è´¥ï¼š${result.message}`,
          action: 'save'
        };
      }

    } catch (error) {
      Logger.error('MemoryManager', `ä¿å­˜ç”¨æˆ·è®°å¿†å¼‚å¸¸: ${error}`);
      return {
        success: false,
        message: `è®°å¿†ä¿å­˜å¼‚å¸¸ï¼š${error}`,
        action: 'save'
      };
    }
  }

  /**
   * ä»æ¶ˆæ¯å†…å®¹ä¿å­˜ç”¨æˆ·è®°å¿†
   */
  async saveMemoryFromMessage(messageId: string, content: string, sessionId?: string): Promise<MemoryOperationFeedback> {
    const request: SaveUserMemoryRequest = {
      content: content,
      triggerSource: MemoryTriggerSource.USER_CLICK,
      contentType: MemoryContentType.MESSAGE,
      sessionId: sessionId,
      messageId: messageId,
      originalContext: content
    };

    return await this.saveUserMemory(request);
  }

  /**
   * ç”Ÿæˆè®°å¿†æ ‡é¢˜
   */
  private generateTitle(content: string): string {
    const maxLength = this.userMemoryConfig.maxTitleLength;

    // å¦‚æœå†…å®¹è¾ƒçŸ­ï¼Œç›´æ¥ä½¿ç”¨å†…å®¹ä½œä¸ºæ ‡é¢˜
    if (content.length <= maxLength) {
      return content;
    }

    // å°è¯•æ‰¾åˆ°åˆé€‚çš„æˆªæ–­ç‚¹
    const sentences = content.split(/[ã€‚ï¼ï¼Ÿ.!?]/);
    if (sentences.length > 1 && sentences[0].length <= maxLength) {
      return sentences[0];
    }

    // æŒ‰è¯æˆªæ–­
    const words = content.split(/\s+/);
    let title = '';
    for (const word of words) {
      if (title.length + word.length + 1 <= maxLength) {
        title += (title ? ' ' : '') + word;
      } else {
        break;
      }
    }

    // å¦‚æœè¿˜æ˜¯å¤ªé•¿ï¼Œç›´æ¥æˆªæ–­
    if (!title || title.length === 0) {
      title = content.substring(0, maxLength - 3) + '...';
    }

    return title;
  }

  /**
   * æ¨æ–­å†…å®¹ç±»å‹
   */
  private inferContentType(content: string): MemoryContentType {
    // æ£€æµ‹ä»£ç ç‰¹å¾
    const codePatterns = [
      /```[\s\S]*?```/,  // ä»£ç å—
      /`[^`]+`/,         // è¡Œå†…ä»£ç 
      /function\s+\w+/,  // JavaScriptå‡½æ•°
      /def\s+\w+/,       // Pythonå‡½æ•°
      /class\s+\w+/,     // ç±»å®šä¹‰
      /import\s+/,       // å¯¼å…¥è¯­å¥
      /console\.log/,    // æ§åˆ¶å°è¾“å‡º
      /print\s*\(/       // æ‰“å°å‡½æ•°
    ];

    for (const pattern of codePatterns) {
      if (pattern.test(content)) {
        return MemoryContentType.CODE;
      }
    }

    // å¦‚æœåŒ…å«é—®ç­”æ ¼å¼ï¼Œå¯èƒ½æ˜¯å¯¹è¯
    if (content.includes('é—®ï¼š') || content.includes('ç­”ï¼š') ||
        content.includes('Q:') || content.includes('A:')) {
      return MemoryContentType.CONVERSATION;
    }

    // é»˜è®¤ä¸ºæ–‡æœ¬
    return MemoryContentType.TEXT;
  }

  /**
   * æ¨æ–­è®°å¿†åˆ†ç±»
   */
  private inferCategory(content: string): MemoryCategory {
    const lowerContent = content.toLowerCase();

    // ä¸ªäººä¿¡æ¯å…³é”®è¯
    const personalKeywords = ['æˆ‘å«', 'æˆ‘æ˜¯', 'æˆ‘çš„åå­—', 'æˆ‘çš„ç”Ÿæ—¥', 'æˆ‘ä½åœ¨', 'æˆ‘æ¥è‡ª'];
    if (personalKeywords.some(keyword => lowerContent.includes(keyword))) {
      return MemoryCategory.PERSONAL;
    }

    // åå¥½å…³é”®è¯
    const preferenceKeywords = ['æˆ‘å–œæ¬¢', 'æˆ‘ä¸å–œæ¬¢', 'æˆ‘çˆ±', 'æˆ‘è®¨åŒ', 'æˆ‘åå¥½', 'æˆ‘ä¹ æƒ¯'];
    if (preferenceKeywords.some(keyword => lowerContent.includes(keyword))) {
      return MemoryCategory.PREFERENCE;
    }

    // å·¥ä½œå…³é”®è¯
    const workKeywords = ['å·¥ä½œ', 'å…¬å¸', 'èŒä½', 'åŒäº‹', 'é¡¹ç›®', 'ä¼šè®®', 'èŒä¸š'];
    if (workKeywords.some(keyword => lowerContent.includes(keyword))) {
      return MemoryCategory.WORK;
    }

    // å­¦ä¹ å…³é”®è¯
    const studyKeywords = ['å­¦ä¹ ', 'è¯¾ç¨‹', 'è€ƒè¯•', 'å­¦æ ¡', 'æ•™ç¨‹', 'åŸ¹è®­'];
    if (studyKeywords.some(keyword => lowerContent.includes(keyword))) {
      return MemoryCategory.STUDY;
    }

    // å®¶åº­å…³é”®è¯
    const familyKeywords = ['å®¶äºº', 'çˆ¶æ¯', 'å¦»å­', 'ä¸ˆå¤«', 'å­©å­', 'å®¶åº­'];
    if (familyKeywords.some(keyword => lowerContent.includes(keyword))) {
      return MemoryCategory.FAMILY;
    }

    // å¥åº·å…³é”®è¯
    const healthKeywords = ['å¥åº·', 'åŒ»ç”Ÿ', 'è¯ç‰©', 'è¿åŠ¨', 'é”»ç‚¼', 'é¥®é£Ÿ'];
    if (healthKeywords.some(keyword => lowerContent.includes(keyword))) {
      return MemoryCategory.HEALTH;
    }

    // çˆ±å¥½å…³é”®è¯
    const hobbyKeywords = ['çˆ±å¥½', 'å…´è¶£', 'å¨±ä¹', 'æ¸¸æˆ', 'ç”µå½±', 'éŸ³ä¹', 'é˜…è¯»'];
    if (hobbyKeywords.some(keyword => lowerContent.includes(keyword))) {
      return MemoryCategory.HOBBY;
    }

    // é»˜è®¤ä¸ºè‡ªå®šä¹‰
    return MemoryCategory.CUSTOM;
  }

  /**
   * å»ºè®®æ ‡ç­¾
   */
  private suggestTags(content: string): string[] {
    const tags: string[] = [];
    const lowerContent = content.toLowerCase();

    // åŸºäºå…³é”®è¯çš„æ ‡ç­¾å»ºè®®
    const tagMap: Record<string, string[]> = {
      'å·¥ä½œ': ['å·¥ä½œ', 'èŒä¸š'],
      'å­¦ä¹ ': ['å­¦ä¹ ', 'æ•™è‚²'],
      'å®¶åº­': ['å®¶åº­', 'äº²æƒ…'],
      'å¥åº·': ['å¥åº·', 'åŒ»ç–—'],
      'çˆ±å¥½': ['çˆ±å¥½', 'å…´è¶£'],
      'æ—…è¡Œ': ['æ—…è¡Œ', 'å‡ºè¡Œ'],
      'ç¾é£Ÿ': ['ç¾é£Ÿ', 'é¥®é£Ÿ'],
      'è¿åŠ¨': ['è¿åŠ¨', 'å¥èº«'],
      'éŸ³ä¹': ['éŸ³ä¹', 'å¨±ä¹'],
      'ç”µå½±': ['ç”µå½±', 'å¨±ä¹'],
      'é˜…è¯»': ['é˜…è¯»', 'å­¦ä¹ '],
      'ç¼–ç¨‹': ['ç¼–ç¨‹', 'æŠ€æœ¯'],
      'æŠ€æœ¯': ['æŠ€æœ¯', 'å·¥ä½œ']
    };

    Object.entries(tagMap).forEach((entry: [string, string[]]) => {
      const keyword = entry[0];
      const suggestedTags = entry[1];
      if (lowerContent.includes(keyword)) {
        suggestedTags.forEach(tag => {
          if (!tags.includes(tag)) {
            tags.push(tag);
          }
        });
      }
    });

    // é™åˆ¶æ ‡ç­¾æ•°é‡
    return tags.slice(0, 5);
  }

  /**
   * è·å–æ”¯æŒçš„è®°å¿†æŒ‡ä»¤åˆ—è¡¨
   */
  getSupportedCommands(): MemoryCommand[] {
    const result: MemoryCommand[] = [];
    for (let i = 0; i < this.supportedCommands.length; i++) {
      result.push(this.supportedCommands[i]);
    }
    return result;
  }

  /**
   * è·å–ç”¨æˆ·è®°å¿†é…ç½®
   */
  getUserMemoryConfig(): UserMemoryManagerConfig {
    return {
      autoGenerateTitle: this.userMemoryConfig.autoGenerateTitle,
      maxTitleLength: this.userMemoryConfig.maxTitleLength,
      defaultCategory: this.userMemoryConfig.defaultCategory,
      defaultImportance: this.userMemoryConfig.defaultImportance,
      enableTagSuggestion: this.userMemoryConfig.enableTagSuggestion,
      maxRecentMemories: this.userMemoryConfig.maxRecentMemories,
      enableExportImport: this.userMemoryConfig.enableExportImport
    };
  }

  /**
   * æ›´æ–°ç”¨æˆ·è®°å¿†é…ç½®
   */
  updateUserMemoryConfig(config: Partial<UserMemoryManagerConfig>): void {
    if (config.autoGenerateTitle !== undefined) {
      this.userMemoryConfig.autoGenerateTitle = config.autoGenerateTitle;
    }
    if (config.maxTitleLength !== undefined) {
      this.userMemoryConfig.maxTitleLength = config.maxTitleLength;
    }
    if (config.defaultCategory !== undefined) {
      this.userMemoryConfig.defaultCategory = config.defaultCategory;
    }
    if (config.defaultImportance !== undefined) {
      this.userMemoryConfig.defaultImportance = config.defaultImportance;
    }
    if (config.enableTagSuggestion !== undefined) {
      this.userMemoryConfig.enableTagSuggestion = config.enableTagSuggestion;
    }
    if (config.maxRecentMemories !== undefined) {
      this.userMemoryConfig.maxRecentMemories = config.maxRecentMemories;
    }
    if (config.enableExportImport !== undefined) {
      this.userMemoryConfig.enableExportImport = config.enableExportImport;
    }
    Logger.info('MemoryManager', 'ç”¨æˆ·è®°å¿†é…ç½®å·²æ›´æ–°');
  }

}