import {
  MemoryFragment,
  MemoryCategory,
  MemoryImportance,
  MemoryStats,
  MemoryCategoryCounts,
  MemoryImportanceCounts,
  CreateMemoryRequest,
  UpdateMemoryRequest,
  MemoryFilterOptions,
  MemorySortBy,
  MemorySortDirection,
  MemorySortOptions,
  MemoryOperationResult,
  MemoryInjectionConfig,
  MemoryItem
} from '../types/MemoryTypes';
import { AppStorage } from './AppStorage';
import { Logger } from './Logger';

export interface MemoryItemWithoutId {
  title: string;
  content: string;
  tags: string[];
  category: MemoryCategory;
  importance: MemoryImportance;
  isActive: boolean;
  createdAt: number;
  updatedAt: number;
  usageCount: number;
  lastUsedAt: number;
}

/**
 * è®°å¿†ç®¡ç†å™¨ - è´Ÿè´£ç”¨æˆ·è®°å¿†ç¢ç‰‡çš„ç®¡ç†
 */
export class MemoryManager {
  private static instance: MemoryManager | null = null;
  private readonly MEMORY_STORAGE_KEY = 'user_memories';
  private readonly MEMORY_CONFIG_KEY = 'memory_injection_config';
  private readonly MEMORY_STATS_KEY = 'memory_stats_cache';
  private memoryStatsListeners: Array<(stats: MemoryStats) => void> = [];

  private constructor() {}

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  static getInstance(): MemoryManager {
    if (!MemoryManager.instance) {
      MemoryManager.instance = new MemoryManager();
    }
    return MemoryManager.instance;
  }

  /**
   * ç”Ÿæˆå”¯ä¸€ID
   */
  private generateId(): string {
    return `memory_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * è·å–æ‰€æœ‰è®°å¿†ç¢ç‰‡
   */
  async getAllMemories(): Promise<MemoryFragment[]> {
    try {
      const storage = AppStorage.getPreferences();
      const jsonStr = await storage.get(this.MEMORY_STORAGE_KEY, '[]');
      const memories = JSON.parse(jsonStr as string) as MemoryFragment[];
      Logger.debug('MemoryManager', `è·å–åˆ° ${memories.length} ä¸ªè®°å¿†ç¢ç‰‡`);
      return memories;
    } catch (error) {
      Logger.error('MemoryManager', `è·å–è®°å¿†ç¢ç‰‡å¤±è´¥: ${error}`);
      return [];
    }
  }

  /**
   * åˆ›å»ºæ–°çš„è®°å¿†ç¢ç‰‡
   */
  async createMemory(request: CreateMemoryRequest): Promise<MemoryOperationResult> {
    try {
      if (!request.content || !request.content.trim()) {
        return {
          success: false,
          message: 'è®°å¿†å†…å®¹ä¸èƒ½ä¸ºç©º'
        };
      }

      const now = Date.now();
      const memory: MemoryFragment = {
        id: this.generateId(),
        content: request.content.trim(),
        tags: request.tags || [],
        category: request.category || MemoryCategory.CUSTOM,
        importance: request.importance || MemoryImportance.MEDIUM,
        isActive: request.isActive !== undefined ? request.isActive : true,
        createdAt: now,
        updatedAt: now,
        usageCount: 0,
        lastUsedAt: 0
      };

      const memories = await this.getAllMemories();
      memories.push(memory);

      const storage = AppStorage.getPreferences();
      await storage.put(this.MEMORY_STORAGE_KEY, JSON.stringify(memories));
      await storage.flush();

      // æ›´æ–°ç»Ÿè®¡ç¼“å­˜
      await this.updateMemoryStatsCache();

      Logger.info('MemoryManager', `åˆ›å»ºè®°å¿†ç¢ç‰‡æˆåŠŸ: ${memory.id}`);
      return {
        success: true,
        message: 'è®°å¿†ç¢ç‰‡åˆ›å»ºæˆåŠŸ',
        data: memory
      };

    } catch (error) {
      Logger.error('MemoryManager', `åˆ›å»ºè®°å¿†ç¢ç‰‡å¤±è´¥: ${error}`);
      return {
        success: false,
        message: `åˆ›å»ºè®°å¿†ç¢ç‰‡å¤±è´¥: ${error}`
      };
    }
  }

  /**
   * æ›´æ–°è®°å¿†ç¢ç‰‡
   */
  async updateMemory(id: string, request: UpdateMemoryRequest): Promise<MemoryOperationResult> {
    try {
      const memories = await this.getAllMemories();
      const index = memories.findIndex(m => m.id === id);

      if (index === -1) {
        return {
          success: false,
          message: 'è®°å¿†ç¢ç‰‡ä¸å­˜åœ¨'
        };
      }

      const memory = memories[index];

      // æ›´æ–°å­—æ®µ
      if (request.content !== undefined) {
        if (!request.content.trim()) {
          return {
            success: false,
            message: 'è®°å¿†å†…å®¹ä¸èƒ½ä¸ºç©º'
          };
        }
        memory.content = request.content.trim();
      }

      if (request.tags !== undefined) {
        memory.tags = request.tags;
      }

      if (request.category !== undefined) {
        memory.category = request.category;
      }

      if (request.importance !== undefined) {
        memory.importance = request.importance;
      }

      if (request.isActive !== undefined) {
        memory.isActive = request.isActive;
      }

      memory.updatedAt = Date.now();

      const storage = AppStorage.getPreferences();
      await storage.put(this.MEMORY_STORAGE_KEY, JSON.stringify(memories));
      await storage.flush();

      Logger.info('MemoryManager', `æ›´æ–°è®°å¿†ç¢ç‰‡æˆåŠŸ: ${id}`);
      return {
        success: true,
        message: 'è®°å¿†ç¢ç‰‡æ›´æ–°æˆåŠŸ',
        data: memory
      };

    } catch (error) {
      Logger.error('MemoryManager', `æ›´æ–°è®°å¿†ç¢ç‰‡å¤±è´¥: ${error}`);
      return {
        success: false,
        message: `æ›´æ–°è®°å¿†ç¢ç‰‡å¤±è´¥: ${error}`
      };
    }
  }

  /**
   * åˆ é™¤è®°å¿†ç¢ç‰‡
   */
  async deleteMemory(id: string): Promise<MemoryOperationResult> {
    try {
      const memories = await this.getAllMemories();
      const index = memories.findIndex(m => m.id === id);

      if (index === -1) {
        return {
          success: false,
          message: 'è®°å¿†ç¢ç‰‡ä¸å­˜åœ¨'
        };
      }

      memories.splice(index, 1);
      const storage = AppStorage.getPreferences();
      await storage.put(this.MEMORY_STORAGE_KEY, JSON.stringify(memories));
      await storage.flush();

      // æ›´æ–°ç»Ÿè®¡ç¼“å­˜
      await this.updateMemoryStatsCache();

      Logger.info('MemoryManager', `åˆ é™¤è®°å¿†ç¢ç‰‡æˆåŠŸ: ${id}`);
      return {
        success: true,
        message: 'è®°å¿†ç¢ç‰‡åˆ é™¤æˆåŠŸ'
      };

    } catch (error) {
      Logger.error('MemoryManager', `åˆ é™¤è®°å¿†ç¢ç‰‡å¤±è´¥: ${error}`);
      return {
        success: false,
        message: `åˆ é™¤è®°å¿†ç¢ç‰‡å¤±è´¥: ${error}`
      };
    }
  }

  /**
   * è·å–å•ä¸ªè®°å¿†ç¢ç‰‡
   */
  async getMemory(id: string): Promise<MemoryFragment | null> {
    try {
      const memories = await this.getAllMemories();
      const memory = memories.find(m => m.id === id);
      return memory || null;
    } catch (error) {
      Logger.error('MemoryManager', `è·å–è®°å¿†ç¢ç‰‡å¤±è´¥: ${error}`);
      return null;
    }
  }

  /**
   * è·å–æ¿€æ´»çš„è®°å¿†ç¢ç‰‡ï¼ˆç”¨äºæ³¨å…¥åˆ°å¯¹è¯ä¸­ï¼‰
   */
  async getActiveMemories(): Promise<MemoryFragment[]> {
    try {
      const memories = await this.getAllMemories();
      const activeMemories = memories.filter(m => m.isActive);

      // æŒ‰é‡è¦æ€§å’Œä½¿ç”¨é¢‘ç‡æ’åº
      activeMemories.sort((a, b) => {
        // é¦–å…ˆæŒ‰é‡è¦æ€§æ’åº
        let aWeight = 0;
        let bWeight = 0;

        // è®¾ç½®açš„æƒé‡
        if (a.importance === MemoryImportance.CRITICAL) aWeight = 4;
        else if (a.importance === MemoryImportance.HIGH) aWeight = 3;
        else if (a.importance === MemoryImportance.MEDIUM) aWeight = 2;
        else if (a.importance === MemoryImportance.LOW) aWeight = 1;

        // è®¾ç½®bçš„æƒé‡
        if (b.importance === MemoryImportance.CRITICAL) bWeight = 4;
        else if (b.importance === MemoryImportance.HIGH) bWeight = 3;
        else if (b.importance === MemoryImportance.MEDIUM) bWeight = 2;
        else if (b.importance === MemoryImportance.LOW) bWeight = 1;

        if (aWeight !== bWeight) {
          return bWeight - aWeight; // é‡è¦æ€§é«˜çš„åœ¨å‰
        }

        // é‡è¦æ€§ç›¸åŒæ—¶ï¼ŒæŒ‰ä½¿ç”¨é¢‘ç‡æ’åº
        if (a.usageCount !== b.usageCount) {
          return b.usageCount - a.usageCount; // ä½¿ç”¨é¢‘ç‡é«˜çš„åœ¨å‰
        }

        // æœ€åæŒ‰æ›´æ–°æ—¶é—´æ’åº
        return b.updatedAt - a.updatedAt; // æœ€è¿‘æ›´æ–°çš„åœ¨å‰
      });

      Logger.debug('MemoryManager', `è·å–åˆ° ${activeMemories.length} ä¸ªæ¿€æ´»çš„è®°å¿†ç¢ç‰‡`);
      return activeMemories;
    } catch (error) {
      Logger.error('MemoryManager', `è·å–æ¿€æ´»è®°å¿†ç¢ç‰‡å¤±è´¥: ${error}`);
      return [];
    }
  }

  /**
   * æœç´¢è®°å¿†ç¢ç‰‡
   */
  async searchMemories(keyword: string): Promise<MemoryFragment[]> {
    try {
      if (!keyword || !keyword.trim()) {
        return await this.getAllMemories();
      }

      const memories = await this.getAllMemories();
      const lowerKeyword = keyword.toLowerCase().trim();

      // å°†å…³é”®è¯æŒ‰ç©ºæ ¼åˆ†å‰²æˆå¤šä¸ªè¯æ±‡è¿›è¡Œæœç´¢
      const keywords = lowerKeyword.split(/\s+/).filter(k => k.length > 0);

      const matchedMemories = memories.filter(memory => {
        const lowerContent = memory.content.toLowerCase();
        const lowerTags = memory.tags.map(tag => tag.toLowerCase());

        // æ£€æŸ¥æ˜¯å¦æœ‰ä»»ä½•ä¸€ä¸ªå…³é”®è¯åŒ¹é…å†…å®¹æˆ–æ ‡ç­¾
        const hasMatch = keywords.some(kw => {
          const contentMatch = lowerContent.includes(kw);
          const tagMatch = lowerTags.some(tag => tag.includes(kw));
          return contentMatch || tagMatch;
        });

        return hasMatch;
      });

      Logger.debug('MemoryManager', `æœç´¢å…³é”®è¯ "${keyword}" (åˆ†è§£ä¸º: ${keywords.join(', ')}) æ‰¾åˆ° ${matchedMemories.length} ä¸ªè®°å¿†ç¢ç‰‡`);
      return matchedMemories;
    } catch (error) {
      Logger.error('MemoryManager', `æœç´¢è®°å¿†ç¢ç‰‡å¤±è´¥: ${error}`);
      return [];
    }
  }

  /**
   * æŒ‰åˆ†ç±»è·å–è®°å¿†ç¢ç‰‡
   */
  async getMemoriesByCategory(category: MemoryCategory): Promise<MemoryFragment[]> {
    try {
      const memories = await this.getAllMemories();
      const categoryMemories = memories.filter(m => m.category === category);

      Logger.debug('MemoryManager', `åˆ†ç±» ${category} æœ‰ ${categoryMemories.length} ä¸ªè®°å¿†ç¢ç‰‡`);
      return categoryMemories;
    } catch (error) {
      Logger.error('MemoryManager', `æŒ‰åˆ†ç±»è·å–è®°å¿†ç¢ç‰‡å¤±è´¥: ${error}`);
      return [];
    }
  }

  /**
   * è·å–è®°å¿†ç»Ÿè®¡ä¿¡æ¯
   */
  async getMemoryStats(): Promise<MemoryStats> {
    try {
      const memories = await this.getAllMemories();

      const categoryCounts: MemoryCategoryCounts = {
        personal: 0,
        preference: 0,
        work: 0,
        study: 0,
        hobby: 0,
        family: 0,
        health: 0,
        custom: 0
      };

      const importanceCounts: MemoryImportanceCounts = {
        low: 0,
        medium: 0,
        high: 0,
        critical: 0
      };

      let lastUpdated = 0;
      let totalUsageCount = 0;

      memories.forEach(memory => {
        // æ›´æ–°åˆ†ç±»ç»Ÿè®¡
        if (memory.category === MemoryCategory.PERSONAL) categoryCounts.personal++;
        else if (memory.category === MemoryCategory.PREFERENCE) categoryCounts.preference++;
        else if (memory.category === MemoryCategory.WORK) categoryCounts.work++;
        else if (memory.category === MemoryCategory.STUDY) categoryCounts.study++;
        else if (memory.category === MemoryCategory.HOBBY) categoryCounts.hobby++;
        else if (memory.category === MemoryCategory.FAMILY) categoryCounts.family++;
        else if (memory.category === MemoryCategory.HEALTH) categoryCounts.health++;
        else if (memory.category === MemoryCategory.CUSTOM) categoryCounts.custom++;

        // æ›´æ–°é‡è¦æ€§ç»Ÿè®¡
        if (memory.importance === MemoryImportance.LOW) importanceCounts.low++;
        else if (memory.importance === MemoryImportance.MEDIUM) importanceCounts.medium++;
        else if (memory.importance === MemoryImportance.HIGH) importanceCounts.high++;
        else if (memory.importance === MemoryImportance.CRITICAL) importanceCounts.critical++;

        totalUsageCount += memory.usageCount;

        if (memory.updatedAt > lastUpdated) {
          lastUpdated = memory.updatedAt;
        }
      });

      const stats: MemoryStats = {
        totalFragments: memories.length,
        activeFragments: memories.filter(m => m.isActive).length,
        categoryCounts: categoryCounts,
        importanceCounts: importanceCounts,
        lastUpdated: lastUpdated,
        totalUsageCount: totalUsageCount
      };

      return stats;
    } catch (error) {
      Logger.error('MemoryManager', `è·å–è®°å¿†ç»Ÿè®¡å¤±è´¥: ${error}`);
      return {
        totalFragments: 0,
        activeFragments: 0,
        categoryCounts: {
          personal: 0,
          preference: 0,
          work: 0,
          study: 0,
          hobby: 0,
          family: 0,
          health: 0,
          custom: 0
        },
        importanceCounts: {
          low: 0,
          medium: 0,
          high: 0,
          critical: 0
        },
        lastUpdated: 0,
        totalUsageCount: 0
      };
    }
  }

  /**
   * å¢åŠ è®°å¿†ä½¿ç”¨æ¬¡æ•°
   */
  async incrementUsageCount(id: string): Promise<void> {
    try {
      const memories = await this.getAllMemories();
      const memory = memories.find(m => m.id === id);

      if (memory) {
        memory.usageCount++;
        memory.lastUsedAt = Date.now();
        const storage = AppStorage.getPreferences();
      await storage.put(this.MEMORY_STORAGE_KEY, JSON.stringify(memories));
      await storage.flush();
        Logger.debug('MemoryManager', `è®°å¿†ç¢ç‰‡ ${id} ä½¿ç”¨æ¬¡æ•°å¢åŠ è‡³ ${memory.usageCount}`);
      }
    } catch (error) {
      Logger.error('MemoryManager', `å¢åŠ ä½¿ç”¨æ¬¡æ•°å¤±è´¥: ${error}`);
    }
  }

  /**
   * ç”Ÿæˆè®°å¿†æ³¨å…¥æ–‡æœ¬ï¼ˆç”¨äºç³»ç»Ÿæç¤ºè¯ï¼‰
   */
  async generateMemoryInjectionText(): Promise<string> {
    try {
      const activeMemories = await this.getActiveMemories();

      if (activeMemories.length === 0) {
        return '';
      }

      // é™åˆ¶æœ€å¤§æ•°é‡ï¼ˆé¿å…æç¤ºè¯è¿‡é•¿ï¼‰
      const maxMemories = 10;
      const memoriesToUse = activeMemories.slice(0, maxMemories);

      // å¢åŠ ä½¿ç”¨æ¬¡æ•°
      for (const memory of memoriesToUse) {
        await this.incrementUsageCount(memory.id);
      }

      // ç”Ÿæˆæ³¨å…¥æ–‡æœ¬
      const memoryLines = memoriesToUse.map(memory => `- ${memory.content}`);

      const injectionText = `---
è¿™æ˜¯å…³äºç”¨æˆ·çš„ä¸€äº›é‡è¦è®°å¿†ï¼Œè¯·åœ¨å›ç­”æ—¶å‚è€ƒï¼š
${memoryLines.join('\n')}
---`;

      Logger.info('MemoryManager', `ç”Ÿæˆè®°å¿†æ³¨å…¥æ–‡æœ¬ï¼ŒåŒ…å« ${memoriesToUse.length} ä¸ªè®°å¿†ç¢ç‰‡`);
      return injectionText;

    } catch (error) {
      Logger.error('MemoryManager', `ç”Ÿæˆè®°å¿†æ³¨å…¥æ–‡æœ¬å¤±è´¥: ${error}`);
      return '';
    }
  }

  /**
   * åˆ‡æ¢è®°å¿†ç¢ç‰‡çš„æ¿€æ´»çŠ¶æ€
   */
  async toggleMemoryActive(id: string): Promise<MemoryOperationResult> {
    try {
      const memories = await this.getAllMemories();
      const memory = memories.find(m => m.id === id);

      if (!memory) {
        return {
          success: false,
          message: 'è®°å¿†ç¢ç‰‡ä¸å­˜åœ¨'
        };
      }

      memory.isActive = !memory.isActive;
      memory.updatedAt = Date.now();

      const storage = AppStorage.getPreferences();
      await storage.put(this.MEMORY_STORAGE_KEY, JSON.stringify(memories));
      await storage.flush();

      Logger.info('MemoryManager', `è®°å¿†ç¢ç‰‡ ${id} æ¿€æ´»çŠ¶æ€åˆ‡æ¢ä¸º: ${memory.isActive}`);
      return {
        success: true,
        message: `è®°å¿†ç¢ç‰‡å·²${memory.isActive ? 'æ¿€æ´»' : 'åœç”¨'}`,
        data: memory
      };

    } catch (error) {
      Logger.error('MemoryManager', `åˆ‡æ¢è®°å¿†ç¢ç‰‡æ¿€æ´»çŠ¶æ€å¤±è´¥: ${error}`);
      return {
        success: false,
        message: `åˆ‡æ¢æ¿€æ´»çŠ¶æ€å¤±è´¥: ${error}`
      };
    }
  }

  /**
   * æ¸…ç©ºæ‰€æœ‰è®°å¿†ç¢ç‰‡
   */
  async clearAllMemories(): Promise<MemoryOperationResult> {
    try {
      const storage = AppStorage.getPreferences();
      await storage.put(this.MEMORY_STORAGE_KEY, JSON.stringify([]));
      await storage.flush();

      Logger.info('MemoryManager', 'å·²æ¸…ç©ºæ‰€æœ‰è®°å¿†ç¢ç‰‡');
      return {
        success: true,
        message: 'æ‰€æœ‰è®°å¿†ç¢ç‰‡å·²æ¸…ç©º'
      };

    } catch (error) {
      Logger.error('MemoryManager', `æ¸…ç©ºè®°å¿†ç¢ç‰‡å¤±è´¥: ${error}`);
      return {
        success: false,
        message: `æ¸…ç©ºå¤±è´¥: ${error}`
      };
    }
  }

  /**
   * è·å–è®°å¿†é¡¹åˆ—è¡¨ï¼ˆå…¼å®¹MemoryItemæ¥å£ï¼‰
   */
  async getMemoryItems(): Promise<MemoryItem[]> {
    const fragments = await this.getAllMemories();
    return fragments.map(fragment => ({
      id: fragment.id,
      title: `è®°å¿†-${fragment.createdAt}`,
      content: fragment.content,
      tags: fragment.tags,
      category: fragment.category,
      importance: fragment.importance,
      isActive: fragment.isActive,
      createdAt: fragment.createdAt,
      updatedAt: fragment.updatedAt,
      usageCount: fragment.usageCount,
      lastUsedAt: fragment.lastUsedAt
    } as MemoryItem));
  }

  /**
   * æ·»åŠ è®°å¿†é¡¹ï¼ˆå…¼å®¹MemoryItemæ¥å£ï¼‰
   */
  async addMemoryItem(item: MemoryItemWithoutId): Promise<MemoryItem> {
    const request: CreateMemoryRequest = {
      content: item.content,
      tags: item.tags,
      category: item.category,
      importance: item.importance,
      isActive: item.isActive
    };

    const result = await this.createMemory(request);
    if (result.success && result.data) {
      const fragment = Array.isArray(result.data) ? result.data[0] : result.data;
      return {
        id: fragment.id,
        title: `è®°å¿†-${fragment.createdAt}`,
        content: fragment.content,
        tags: fragment.tags,
        category: fragment.category,
        importance: fragment.importance,
        isActive: fragment.isActive,
        createdAt: fragment.createdAt,
        updatedAt: fragment.updatedAt,
        usageCount: fragment.usageCount,
        lastUsedAt: fragment.lastUsedAt
      } as MemoryItem;
    }
    throw new Error(result.message || 'æ·»åŠ è®°å¿†å¤±è´¥');
  }

  /**
   * æ›´æ–°è®°å¿†é¡¹ï¼ˆå…¼å®¹MemoryItemæ¥å£ï¼‰
   */
  async updateMemoryItem(id: string, item: MemoryItemWithoutId): Promise<MemoryItem> {
    const request: UpdateMemoryRequest = {
      content: item.content,
      tags: item.tags,
      category: item.category,
      importance: item.importance,
      isActive: item.isActive
    };

    Logger.debug('MemoryManager', `updateMemoryItemè°ƒç”¨ï¼ŒID: ${id}, å†…å®¹é•¿åº¦: ${item.content.length}`);
    const result = await this.updateMemory(id, request);
    if (result.success && result.data) {
      const fragment = Array.isArray(result.data) ? result.data[0] : result.data;
      // ğŸ”§ ä¿®å¤ï¼šä½¿ç”¨åŠ¨æ€ç”Ÿæˆçš„titleè€Œä¸æ˜¯ä¼ å…¥çš„title
      const generatedTitle = `è®°å¿†-${fragment.createdAt}`;
      Logger.debug('MemoryManager', `updateMemoryItemæˆåŠŸï¼Œç”Ÿæˆtitle: ${generatedTitle}`);
      return {
        id: fragment.id,
        title: generatedTitle, // ä½¿ç”¨åŠ¨æ€ç”Ÿæˆçš„title
        content: fragment.content,
        tags: fragment.tags,
        category: fragment.category,
        importance: fragment.importance,
        isActive: fragment.isActive,
        createdAt: fragment.createdAt,
        updatedAt: fragment.updatedAt,
        usageCount: fragment.usageCount,
        lastUsedAt: fragment.lastUsedAt
      } as MemoryItem;
    }
    Logger.error('MemoryManager', `updateMemoryItemå¤±è´¥: ${result.message}`);
    throw new Error(result.message || 'æ›´æ–°è®°å¿†å¤±è´¥');
  }

  /**
   * åˆ é™¤è®°å¿†é¡¹ï¼ˆå…¼å®¹MemoryItemæ¥å£ï¼‰
   */
  async deleteMemoryItem(id: string): Promise<boolean> {
    const result = await this.deleteMemory(id);
    return result.success;
  }

  /**
   * ä¿å­˜è®°å¿†ç»Ÿè®¡æ•°æ®åˆ°ç¼“å­˜
   */
  private async saveMemoryStatsCache(stats: MemoryStats): Promise<void> {
    try {
      const storage = AppStorage.getPreferences();
      await storage.put(this.MEMORY_STATS_KEY, JSON.stringify(stats));
      await storage.flush();
      Logger.debug('MemoryManager', `è®°å¿†ç»Ÿè®¡æ•°æ®å·²ç¼“å­˜: æ€»è®¡${stats.totalFragments}ä¸ªï¼Œæ¿€æ´»${stats.activeFragments}ä¸ª`);
    } catch (error) {
      Logger.error('MemoryManager', `ä¿å­˜è®°å¿†ç»Ÿè®¡ç¼“å­˜å¤±è´¥: ${error}`);
    }
  }

  /**
   * ä»ç¼“å­˜è·å–è®°å¿†ç»Ÿè®¡æ•°æ®
   */
  async getCachedMemoryStats(): Promise<MemoryStats | null> {
    try {
      const storage = AppStorage.getPreferences();
      const jsonStr = await storage.get(this.MEMORY_STATS_KEY, '');

      if (!jsonStr) {
        Logger.debug('MemoryManager', 'æœªæ‰¾åˆ°è®°å¿†ç»Ÿè®¡ç¼“å­˜');
        return null;
      }

      const stats = JSON.parse(jsonStr as string) as MemoryStats;
      Logger.debug('MemoryManager', `ä»ç¼“å­˜è·å–è®°å¿†ç»Ÿè®¡: æ€»è®¡${stats.totalFragments}ä¸ªï¼Œæ¿€æ´»${stats.activeFragments}ä¸ª`);
      return stats;
    } catch (error) {
      Logger.error('MemoryManager', `è·å–è®°å¿†ç»Ÿè®¡ç¼“å­˜å¤±è´¥: ${error}`);
      return null;
    }
  }

  /**
   * æ›´æ–°è®°å¿†ç»Ÿè®¡ç¼“å­˜ï¼ˆåœ¨æ•°æ®å˜æ›´æ—¶è°ƒç”¨ï¼‰
   */
  async updateMemoryStatsCache(): Promise<void> {
    try {
      const stats = await this.getMemoryStats();
      await this.saveMemoryStatsCache(stats);
      Logger.info('MemoryManager', `è®°å¿†ç»Ÿè®¡ç¼“å­˜å·²æ›´æ–°: æ€»è®¡${stats.totalFragments}ä¸ªï¼Œæ¿€æ´»${stats.activeFragments}ä¸ª`);

      // é€šçŸ¥æ‰€æœ‰ç›‘å¬å™¨
      this.notifyMemoryStatsListeners(stats);
    } catch (error) {
      Logger.error('MemoryManager', `æ›´æ–°è®°å¿†ç»Ÿè®¡ç¼“å­˜å¤±è´¥: ${error}`);
    }
  }

  /**
   * æ·»åŠ è®°å¿†ç»Ÿè®¡å˜æ›´ç›‘å¬å™¨
   */
  addMemoryStatsListener(listener: (stats: MemoryStats) => void): void {
    this.memoryStatsListeners.push(listener);
    Logger.debug('MemoryManager', `æ·»åŠ è®°å¿†ç»Ÿè®¡ç›‘å¬å™¨ï¼Œå½“å‰ç›‘å¬å™¨æ•°é‡: ${this.memoryStatsListeners.length}`);
  }

  /**
   * ç§»é™¤è®°å¿†ç»Ÿè®¡å˜æ›´ç›‘å¬å™¨
   */
  removeMemoryStatsListener(listener: (stats: MemoryStats) => void): void {
    const index = this.memoryStatsListeners.indexOf(listener);
    if (index > -1) {
      this.memoryStatsListeners.splice(index, 1);
      Logger.debug('MemoryManager', `ç§»é™¤è®°å¿†ç»Ÿè®¡ç›‘å¬å™¨ï¼Œå½“å‰ç›‘å¬å™¨æ•°é‡: ${this.memoryStatsListeners.length}`);
    }
  }

  /**
   * é€šçŸ¥æ‰€æœ‰è®°å¿†ç»Ÿè®¡ç›‘å¬å™¨
   */
  private notifyMemoryStatsListeners(stats: MemoryStats): void {
    Logger.debug('MemoryManager', `é€šçŸ¥ ${this.memoryStatsListeners.length} ä¸ªè®°å¿†ç»Ÿè®¡ç›‘å¬å™¨`);
    this.memoryStatsListeners.forEach(listener => {
      try {
        listener(stats);
      } catch (error) {
        Logger.error('MemoryManager', `è®°å¿†ç»Ÿè®¡ç›‘å¬å™¨æ‰§è¡Œå¤±è´¥: ${error}`);
      }
    });
  }
}