import { Session, Message, SystemPrompt, MultiRoleSession, SessionParticipant, SessionParticipantData, isMultiRoleSession } from '../models/ChatModels';
import { AppStorage } from './AppStorage';
import { Logger } from './Logger';

interface SessionStats {
  totalSessions: number;
  maxSessions: number;
  currentSessionId: string | null;
}

interface SessionDataQuality {
  totalSessions: number;
  totalMessages: number;
  validMessages: number;
  invalidMessages: number;
  emptyContentMessages: number;
  sessionsWithIssues: string[];
}

interface SaveSessionMessagesOptions {
  participants?: Array<SessionParticipant | SessionParticipantData>;
  name?: string;
}

interface UpdateSessionInfoOptions {
  name?: string;
  messages?: Message[];
  participants?: Array<SessionParticipant | SessionParticipantData>;
}

/**
 * ä¼šè¯ç®¡ç†å™¨ - è´Ÿè´£ä¼šè¯çš„åˆ›å»ºã€åˆ é™¤ã€åˆ‡æ¢ç­‰æ“ä½œ
 */
export class SessionManager {
  private static instance: SessionManager | null = null;
  private readonly MAX_SESSIONS = 10; // æœ€å¤§ä¼šè¯æ•°é‡é™åˆ¶

  private constructor() {}

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  static getInstance(): SessionManager {
    if (!SessionManager.instance) {
      SessionManager.instance = new SessionManager();
    }
    return SessionManager.instance;
  }

  /**
   * è·å–æ‰€æœ‰ä¼šè¯åˆ—è¡¨
   */
  async getSessions(): Promise<Session[]> {
    try {
      Logger.info('SessionManager', 'è·å–ä¼šè¯åˆ—è¡¨');
      const sessions = await AppStorage.getSessions();
      Logger.info('SessionManager', `è·å–åˆ° ${sessions.length} ä¸ªä¼šè¯`);
      return sessions.sort((a, b) => b.updatedAt - a.updatedAt); // æŒ‰æ›´æ–°æ—¶é—´å€’åº
    } catch (error) {
      Logger.error('SessionManager', `è·å–ä¼šè¯åˆ—è¡¨å¤±è´¥: ${error}`);
      return [];
    }
  }

  /**
   * è·å–å½“å‰æ¿€æ´»çš„ä¼šè¯ID
   */
  async getCurrentSessionId(): Promise<string | null> {
    try {
      return await AppStorage.getCurrentSessionId();
    } catch (error) {
      Logger.error('SessionManager', `è·å–å½“å‰ä¼šè¯IDå¤±è´¥: ${error}`);
      return null;
    }
  }

  /**
   * è®¾ç½®å½“å‰æ¿€æ´»çš„ä¼šè¯
   */
  async setCurrentSession(sessionId: string): Promise<void> {
    try {
      await AppStorage.setCurrentSessionId(sessionId);
      Logger.info('SessionManager', `è®¾ç½®å½“å‰ä¼šè¯: ${sessionId}`);
    } catch (error) {
      Logger.error('SessionManager', `è®¾ç½®å½“å‰ä¼šè¯å¤±è´¥: ${error}`);
      throw error as Error;
    }
  }

  /**
   * åˆ›å»ºæ–°ä¼šè¯ï¼ˆå…¼å®¹æ—§æ¥å£ï¼Œä¸ç»‘å®šç³»ç»Ÿæç¤ºè¯ï¼‰
   */
  async createNewSession(firstMessage?: string): Promise<Session> {
    return await this.createNewSessionWithPrompt(null, firstMessage);
  }

  /**
   * åˆ›å»ºæ–°ä¼šè¯ï¼ˆç»‘å®šç³»ç»Ÿæç¤ºè¯ï¼‰
   */
  async createNewSessionWithPrompt(systemPromptId: string | null, firstMessage?: string): Promise<Session> {
    try {
      Logger.info('SessionManager', `åˆ›å»ºæ–°ä¼šè¯ï¼Œç³»ç»Ÿæç¤ºè¯ID: ${systemPromptId || 'æ— '}`);

      // æ£€æŸ¥ä¼šè¯æ•°é‡é™åˆ¶
      const existingSessions = await this.getSessions();
      if (existingSessions.length >= this.MAX_SESSIONS) {
        Logger.warn('SessionManager', `ä¼šè¯æ•°é‡å·²è¾¾ä¸Šé™ ${this.MAX_SESSIONS}`);
        throw Error(`ä¼šè¯æ•°é‡å·²è¾¾ä¸Šé™ ${this.MAX_SESSIONS} ä¸ª`);
      }

      // è·å–ç³»ç»Ÿæç¤ºè¯ä¿¡æ¯ï¼Œåˆ¤æ–­æ˜¯å¦ä¸ºè§’è‰²
      let roleId: string | undefined;
      let sessionName: string;

      if (systemPromptId) {
        const prompts = await AppStorage.getSystemPrompts();
        const prompt = prompts.find(p => p.id === systemPromptId);
        if (prompt && prompt.isRole) {
          roleId = systemPromptId; // å¦‚æœæ˜¯è§’è‰²ï¼Œè®¾ç½®roleId
        }
      }

      // ç”Ÿæˆä¼šè¯åç§°
      if (firstMessage && firstMessage.trim()) {
        const prompt = systemPromptId ? await this.getSystemPromptById(systemPromptId) : null;
        sessionName = Session.generateSessionName(firstMessage, prompt || undefined);
      } else {
        // å¦‚æœæ²¡æœ‰é¦–æ¡æ¶ˆæ¯ï¼Œä½¿ç”¨ä¸´æ—¶åç§°
        if (systemPromptId) {
          const prompt = await this.getSystemPromptById(systemPromptId);
          if (prompt && prompt.isRole) {
            sessionName = `ä¸"${prompt.name}"çš„å¯¹è¯`;
          } else {
            sessionName = 'æ–°å¯¹è¯'; // ä¸´æ—¶åç§°ï¼Œé¦–æ¡æ¶ˆæ¯åä¼šæ›´æ–°
          }
        } else {
          sessionName = `æ–°å¯¹è¯ ${existingSessions.length + 1}`;
        }
      }

      // åˆ›å»ºæ–°ä¼šè¯ï¼ˆä¼ å…¥ç³»ç»Ÿæç¤ºè¯IDå’Œè§’è‰²IDï¼‰
      const session = new Session(sessionName, systemPromptId, roleId);
      Logger.info('SessionManager', `åˆ›å»ºæ–°ä¼šè¯: ${session.id} - ${session.name}, æç¤ºè¯ID: ${systemPromptId || 'æ— '}, è§’è‰²ID: ${roleId || 'æ— '}`);

      // ä¿å­˜ä¼šè¯
      await AppStorage.saveSession(session);

      // è®¾ç½®ä¸ºå½“å‰ä¼šè¯
      await this.setCurrentSession(session.id);

      Logger.info('SessionManager', `æ–°ä¼šè¯åˆ›å»ºæˆåŠŸ: ${session.id}`);
      return session;

    } catch (error) {
      Logger.error('SessionManager', `åˆ›å»ºä¼šè¯å¤±è´¥: ${error}`);
      throw error as Error;
    }
  }

  /**
   * åˆ›å»ºå¤šäººä¼šè¯
   */
  async createMultiRoleSession(participantPrompts: SystemPrompt[]): Promise<MultiRoleSession> {
    try {
      Logger.info('SessionManager', `åˆ›å»ºå¤šäººä¼šè¯ï¼Œå‚ä¸è€…æ•°é‡: ${participantPrompts.length}`);

      const existingSessions = await this.getSessions();
      if (existingSessions.length >= this.MAX_SESSIONS) {
        Logger.warn('SessionManager', `ä¼šè¯æ•°é‡å·²è¾¾ä¸Šé™ ${this.MAX_SESSIONS}`);
        throw new Error(`ä¼šè¯æ•°é‡å·²è¾¾ä¸Šé™ ${this.MAX_SESSIONS} ä¸ª`);
      }

      const participants = participantPrompts.map(prompt =>
        new SessionParticipant(prompt.id, prompt.name, prompt.roleIcon || undefined)
      );
      const normalizedParticipants = this.normalizeParticipants(participants);

      const sessionName = this.buildMultiSessionName(normalizedParticipants, existingSessions.length);
      const session = new MultiRoleSession(sessionName, normalizedParticipants, []);

      await AppStorage.saveSession(session);
      await this.setCurrentSession(session.id);

      Logger.info('SessionManager', `æ–°å¤šäººä¼šè¯åˆ›å»ºæˆåŠŸ: ${session.id}`);
      return session;
    } catch (error) {
      Logger.error('SessionManager', `åˆ›å»ºå¤šäººä¼šè¯å¤±è´¥: ${error}`);
      throw error as Error;
    }
  }

  private buildMultiSessionName(participants: SessionParticipant[], existingCount: number): string {
    const baseName = `å¤šäººä¼šè¯ ${existingCount + 1}`;
    if (!participants || participants.length === 0) {
      return baseName;
    }

    const previewNames = participants.slice(0, 2).map(participant => participant.displayName).join(', ');
    const hasMore = participants.length > 2;
    return `${baseName} (${previewNames}${hasMore ? '...' : ''})`;
  }

  /**
   * é€šè¿‡ç³»ç»Ÿæç¤ºè¯åˆ›å»ºä¸€ä¸ªæ–°ä¼šè¯ï¼Œå¹¶è¿”å›ä¼šè¯ID
   */
  async createSessionFromPrompt(prompt: SystemPrompt): Promise<string> {
    try {
      Logger.info('SessionManager', `ä»æç¤ºè¯åˆ›å»ºæ–°ä¼šè¯: ${prompt.name}`);

      const existingSessions = await this.getSessions();
      if (existingSessions.length >= this.MAX_SESSIONS) {
        Logger.warn('SessionManager', `ä¼šè¯æ•°é‡å·²è¾¾ä¸Šé™ ${this.MAX_SESSIONS}`);
        throw new Error(`ä¼šè¯æ•°é‡å·²è¾¾ä¸Šé™ ${this.MAX_SESSIONS} ä¸ª`);
      }

      // ä½¿ç”¨æç¤ºè¯åç§°ç”Ÿæˆä¼šè¯å
      const sessionName = `ä¸"${prompt.name}"çš„å¯¹è¯`;

      // åˆ›å»ºæ–°ä¼šè¯å¹¶ç»‘å®šç³»ç»Ÿæç¤ºè¯ID
      const session = new Session(sessionName, prompt.id);
      Logger.info('SessionManager', `åˆ›å»ºæ–°ä¼šè¯: ${session.id} - ${session.name}, æç¤ºè¯ID: ${prompt.id}`);

      // ä¿å­˜ä¼šè¯
      await AppStorage.saveSession(session);

      // è®¾ç½®ä¸ºå½“å‰ä¼šè¯
      await this.setCurrentSession(session.id);

      Logger.info('SessionManager', `æ–°ä¼šè¯åˆ›å»ºæˆåŠŸå¹¶è®¾ä¸ºå½“å‰: ${session.id}`);
      return session.id;

    } catch (error) {
      Logger.error('SessionManager', `ä»æç¤ºè¯åˆ›å»ºä¼šè¯å¤±è´¥: ${error}`);
      throw error as Error;
    }
  }

  /**
   * åˆ›å»ºè§’è‰²ä¼šè¯ - ä¸“é—¨ä¸ºè§’è‰²ä¼˜åŒ–çš„ä¼šè¯åˆ›å»º
   */
  async createRoleSession(role: SystemPrompt, firstMessage?: string): Promise<Session> {
    try {
      Logger.info('SessionManager', `åˆ›å»ºè§’è‰²ä¼šè¯: ${role.name}`);

      const existingSessions = await this.getSessions();
      if (existingSessions.length >= this.MAX_SESSIONS) {
        Logger.warn('SessionManager', `ä¼šè¯æ•°é‡å·²è¾¾ä¸Šé™ ${this.MAX_SESSIONS}`);
        throw new Error(`ä¼šè¯æ•°é‡å·²è¾¾ä¸Šé™ ${this.MAX_SESSIONS} ä¸ª`);
      }

      // ä½¿ç”¨è§’è‰²ä¿¡æ¯ç”Ÿæˆä¼šè¯å
      let sessionName: string;
      if (firstMessage && firstMessage.trim()) {
        // å¦‚æœæœ‰é¦–æ¡æ¶ˆæ¯ï¼Œä½¿ç”¨è§’è‰²å+æ¶ˆæ¯å†…å®¹ç”Ÿæˆä¼šè¯å
        const messagePreview = firstMessage.trim().length <= 10
          ? firstMessage.trim()
          : firstMessage.trim().substring(0, 10) + '...';
        sessionName = `[${role.name.split(' ')[0]}] ${messagePreview}`;
      } else {
        // å¦‚æœæ²¡æœ‰é¦–æ¡æ¶ˆæ¯ï¼Œä½¿ç”¨è§’è‰²åç”Ÿæˆä¼šè¯å
        sessionName = `ä¸"${role.name}"çš„å¯¹è¯`;
      }

      // åˆ›å»ºæ–°ä¼šè¯å¹¶ç»‘å®šè§’è‰²IDï¼ˆåŒæ—¶è®¾ç½®systemPromptIdå’ŒroleIdï¼‰
      const session = new Session(sessionName, role.id, role.id);
      Logger.info('SessionManager', `åˆ›å»ºè§’è‰²ä¼šè¯: ${session.id} - ${session.name}, systemPromptId: ${role.id}, roleId: ${role.id}`);

      // ä¿å­˜ä¼šè¯
      await AppStorage.saveSession(session);

      // è®¾ç½®ä¸ºå½“å‰ä¼šè¯
      await this.setCurrentSession(session.id);

      Logger.info('SessionManager', `è§’è‰²ä¼šè¯åˆ›å»ºæˆåŠŸ: ${session.id}`);
      return session;

    } catch (error) {
      Logger.error('SessionManager', `åˆ›å»ºè§’è‰²ä¼šè¯å¤±è´¥: ${error}`);
      throw error as Error;
    }
  }

  /**
   * æ ¹æ®IDè·å–ç³»ç»Ÿæç¤ºè¯
   */
  private async getSystemPromptById(promptId: string): Promise<SystemPrompt | null> {
    try {
      const prompts = await AppStorage.getSystemPrompts();
      const prompt = prompts.find(p => p.id === promptId);
      return prompt || null;
    } catch (error) {
      Logger.error('SessionManager', `è·å–ç³»ç»Ÿæç¤ºè¯å¤±è´¥: ${error}`);
      return null;
    }
  }

  /**
   * è·å–ä¼šè¯ç»‘å®šçš„è§’è‰²ä¿¡æ¯
   */
  async getSessionRole(sessionId: string): Promise<SystemPrompt | null> {
    try {
      const session = (await this.getSessions()).find(s => s.id === sessionId);
      if (!session) {
        return null;
      }

      // ä¼˜å…ˆä½¿ç”¨roleIdï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨systemPromptId
      const roleId = session.roleId || session.systemPromptId;
      if (!roleId) {
        return null;
      }

      // è·å–æ‰€æœ‰ç³»ç»Ÿæç¤ºè¯
      const prompts = await AppStorage.getSystemPrompts();
      const role = prompts.find(p => p.id === roleId && p.isRole);

      if (role) {
        Logger.debug('SessionManager', `è·å–ä¼šè¯è§’è‰²: ${sessionId} -> ${role.name} (ä½¿ç”¨${session.roleId ? 'roleId' : 'systemPromptId'})`);
        return role;
      }

      return null;
    } catch (error) {
      Logger.error('SessionManager', `è·å–ä¼šè¯è§’è‰²å¤±è´¥: ${error}`);
      return null;
    }
  }

  /**
   * åˆ‡æ¢ä¼šè¯çš„è§’è‰²
   */
  async switchSessionRole(sessionId: string, newRoleId: string | null): Promise<void> {
    try {
      Logger.info('SessionManager', `åˆ‡æ¢ä¼šè¯è§’è‰²: ${sessionId} -> ${newRoleId || 'æ— '}`);

      // éªŒè¯æ–°è§’è‰²æ˜¯å¦å­˜åœ¨
      if (newRoleId) {
        const prompts = await AppStorage.getSystemPrompts();
        const role = prompts.find(p => p.id === newRoleId && p.isRole);
        if (!role) {
          throw new Error('æŒ‡å®šçš„è§’è‰²ä¸å­˜åœ¨');
        }
      }

      // è·å–ä¼šè¯
      const sessions = await this.getSessions();
      const session = sessions.find(s => s.id === sessionId);

      if (!session) {
        throw Error('ä¼šè¯ä¸å­˜åœ¨');
      }

      // æ›´æ–°ä¼šè¯çš„ç³»ç»Ÿæç¤ºè¯IDå’Œè§’è‰²ID
      session.systemPromptId = newRoleId;
      session.roleId = newRoleId || undefined; // å¦‚æœä¸ºnullåˆ™è®¾ç½®ä¸ºundefined
      session.updatedAt = Date.now();

      // ä¿å­˜æ›´æ–°
      await AppStorage.saveSession(session);

      Logger.info('SessionManager', `ä¼šè¯è§’è‰²åˆ‡æ¢æˆåŠŸ: ${sessionId} (systemPromptId: ${newRoleId}, roleId: ${session.roleId || 'æ— '})`);
    } catch (error) {
      Logger.error('SessionManager', `åˆ‡æ¢ä¼šè¯è§’è‰²å¤±è´¥: ${error}`);
      throw error as Error;
    }
  }

  /**
   * è·å–æ‰€æœ‰ä½¿ç”¨ç‰¹å®šè§’è‰²çš„ä¼šè¯
   */
  async getSessionsByRole(roleId: string): Promise<Session[]> {
    try {
      const sessions = await this.getSessions();
      // åŒæ—¶æ£€æŸ¥roleIdå’ŒsystemPromptIdï¼Œç¡®ä¿å…¼å®¹æ€§
      const roleSessions = sessions.filter(s => s.roleId === roleId || s.systemPromptId === roleId);

      Logger.debug('SessionManager', `è·å–è§’è‰² ${roleId} çš„ä¼šè¯: ${roleSessions.length} ä¸ª`);
      return roleSessions;
    } catch (error) {
      Logger.error('SessionManager', `è·å–è§’è‰²ä¼šè¯åˆ—è¡¨å¤±è´¥: ${error}`);
      return [];
    }
  }

  /**
   * åˆ é™¤ä¼šè¯
   */
  async deleteSession(sessionId: string): Promise<void> {
    try {
      Logger.info('SessionManager', `åˆ é™¤ä¼šè¯: ${sessionId}`);

      // è·å–æ‰€æœ‰ä¼šè¯
      const sessions = await this.getSessions();
      if (sessions.length <= 1) {
        Logger.warn('SessionManager', 'ä¸èƒ½åˆ é™¤æœ€åä¸€ä¸ªä¼šè¯');
        throw Error('è‡³å°‘éœ€è¦ä¿ç•™ä¸€ä¸ªä¼šè¯');
      }

      // æ£€æŸ¥æ˜¯å¦æ˜¯å½“å‰ä¼šè¯
      const currentSessionId = await this.getCurrentSessionId();
      const isCurrentSession = currentSessionId === sessionId;

      // åˆ é™¤ä¼šè¯æ•°æ®
      await AppStorage.deleteSession(sessionId);
      await AppStorage.deleteSessionMessages(sessionId);

      // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰ä¼šè¯ï¼Œåˆ‡æ¢åˆ°å…¶ä»–ä¼šè¯
      if (isCurrentSession) {
        const remainingSessions = sessions.filter(s => s.id !== sessionId);
        if (remainingSessions.length > 0) {
          await this.setCurrentSession(remainingSessions[0].id);
          Logger.info('SessionManager', `åˆ‡æ¢åˆ°ä¼šè¯: ${remainingSessions[0].id}`);
        }
      }

      Logger.info('SessionManager', `ä¼šè¯åˆ é™¤æˆåŠŸ: ${sessionId}`);

    } catch (error) {
      Logger.error('SessionManager', `åˆ é™¤ä¼šè¯å¤±è´¥: ${error}`);
      throw error as Error;
    }
  }

  /**
   * é‡å‘½åä¼šè¯
   */
  async renameSession(sessionId: string, newName: string): Promise<void> {
    try {
      if (!newName.trim()) {
        throw Error('ä¼šè¯åç§°ä¸èƒ½ä¸ºç©º');
      }

      Logger.info('SessionManager', `é‡å‘½åä¼šè¯: ${sessionId} -> ${newName}`);

      // è·å–ä¼šè¯
      const sessions = await this.getSessions();
      const session = sessions.find(s => s.id === sessionId);
      
      if (!session) {
        throw Error('ä¼šè¯ä¸å­˜åœ¨');
      }

      // æ›´æ–°ä¼šè¯åç§°
      session.updateInfo(session.messageCount, newName.trim());
      
      // ä¿å­˜æ›´æ–°
      await AppStorage.saveSession(session);

      Logger.info('SessionManager', `ä¼šè¯é‡å‘½åæˆåŠŸ: ${sessionId}`);

    } catch (error) {
      Logger.error('SessionManager', `é‡å‘½åä¼šè¯å¤±è´¥: ${error}`);
      throw error as Error;
    }
  }

  /**
   * æ›´æ–°ä¼šè¯çš„ç³»ç»Ÿæç¤ºè¯
   */
  async updateSessionPrompt(sessionId: string, systemPromptId: string | null): Promise<void> {
    try {
      Logger.info('SessionManager', `æ›´æ–°ä¼šè¯ç³»ç»Ÿæç¤ºè¯: ${sessionId} -> ${systemPromptId || 'æ— '}`);

      // è·å–ä¼šè¯
      const sessions = await this.getSessions();
      const session = sessions.find(s => s.id === sessionId);
      
      if (!session) {
        throw Error('ä¼šè¯ä¸å­˜åœ¨');
      }

      // æ›´æ–°ä¼šè¯çš„ç³»ç»Ÿæç¤ºè¯ID
      session.systemPromptId = systemPromptId;
      session.updatedAt = Date.now();
      
      // ä¿å­˜æ›´æ–°
      await AppStorage.saveSession(session);

      Logger.info('SessionManager', `ä¼šè¯ç³»ç»Ÿæç¤ºè¯æ›´æ–°æˆåŠŸ: ${sessionId}`);

    } catch (error) {
      Logger.error('SessionManager', `æ›´æ–°ä¼šè¯ç³»ç»Ÿæç¤ºè¯å¤±è´¥: ${error}`);
      throw error as Error;
    }
  }

  /**
   * è·å–ä¼šè¯çš„æ¶ˆæ¯åˆ—è¡¨
   */
  async getSessionMessages(sessionId: string): Promise<Message[]> {
    try {
      const messages = await AppStorage.getSessionMessages(sessionId);
      Logger.debug('SessionManager', `è·å–ä¼šè¯æ¶ˆæ¯: ${sessionId}, æ•°é‡: ${messages.length}`);
      return messages;
    } catch (error) {
      Logger.error('SessionManager', `è·å–ä¼šè¯æ¶ˆæ¯å¤±è´¥: ${error}`);
      return [];
    }
  }

  /**
   * ä¿å­˜ä¼šè¯æ¶ˆæ¯
   */
  async saveSessionMessages(
    sessionId: string,
    messages: Message[],
    options?: SaveSessionMessagesOptions
  ): Promise<void> {
    try {
      await AppStorage.saveSessionMessages(sessionId, messages);

      // æ›´æ–°ä¼šè¯çš„æ¶ˆæ¯æ•°é‡ã€æ›´æ–°æ—¶é—´åŠå‚ä¸è€…å¿«ç…§
      const updateOptions: UpdateSessionInfoOptions = {
        messages,
        participants: options?.participants,
        name: options?.name
      };
      await this.updateSessionInfo(sessionId, messages.length, updateOptions);

      Logger.debug('SessionManager', `ä¿å­˜ä¼šè¯æ¶ˆæ¯: ${sessionId}, æ•°é‡: ${messages.length}`);
    } catch (error) {
      Logger.error('SessionManager', `ä¿å­˜ä¼šè¯æ¶ˆæ¯å¤±è´¥: ${error}`);
      throw error as Error;
    }
  }

  /**
   * æ›´æ–°ä¼šè¯ä¿¡æ¯ï¼ˆæ¶ˆæ¯æ•°é‡ã€æ›´æ–°æ—¶é—´ç­‰ï¼‰
   */
  async updateSessionInfo(
    sessionId: string,
    messageCount?: number,
    options?: UpdateSessionInfoOptions
  ): Promise<void> {
    try {
      const sessions = await this.getSessions();
      const session = sessions.find(s => s.id === sessionId);

      if (session) {
        const nextMessageCount = messageCount ?? options?.messages?.length ?? session.messageCount;
        const nextName = options?.name ?? session.name;

        session.updateInfo(nextMessageCount, nextName);

        if (isMultiRoleSession(session)) {
          const multiSession = session as MultiRoleSession;
          const snapshotMessages = options?.messages;

          if (snapshotMessages) {
            multiSession.messages = snapshotMessages.map(message => Message.fromObject(message.toObject()));
          }

          if (options?.participants !== undefined) {
            multiSession.participants = this.normalizeParticipants(options.participants);
          } else if (snapshotMessages) {
            multiSession.participants = this.buildParticipantSnapshot(snapshotMessages, multiSession.participants);
          }
        }

        await AppStorage.saveSession(session);
        Logger.debug('SessionManager', `æ›´æ–°ä¼šè¯ä¿¡æ¯: ${sessionId}`);
      }
    } catch (error) {
      Logger.error('SessionManager', `æ›´æ–°ä¼šè¯ä¿¡æ¯å¤±è´¥: ${error}`);
    }
  }

  private normalizeParticipants(participants: Array<SessionParticipant | SessionParticipantData>): SessionParticipant[] {
    return participants
      .filter(participant => participant !== undefined && participant !== null)
      .map(participant => {
      if (participant instanceof SessionParticipant) {
        return SessionParticipant.fromObject(participant.toObject());
      }
      return SessionParticipant.fromObject(participant);
    });
  }

  private buildParticipantSnapshot(
    messages: Message[],
    existingParticipants: Array<SessionParticipant | SessionParticipantData> = []
  ): SessionParticipant[] {
    const participantsMap = new Map<string, SessionParticipant>();

    this.normalizeParticipants(existingParticipants).forEach(existing => {
      if (!existing.roleId) {
        return;
      }
      participantsMap.set(existing.roleId, existing);
    });

    messages.forEach(message => {
      const roleKey = message.senderRoleId || message.role;
      if (!roleKey) {
        return;
      }

      const existing = participantsMap.get(roleKey);
      const displayName = message.senderName || existing?.displayName || roleKey;
      const avatar = message.senderAvatar !== undefined ? message.senderAvatar : existing?.avatar;
      const model = existing?.model;

      if (existing) {
        existing.displayName = displayName;
        existing.avatar = avatar;
      } else {
        participantsMap.set(roleKey, new SessionParticipant(roleKey, displayName, avatar, model));
      }
    });

    return Array.from(participantsMap.values());
  }

  /**
   * æ„å»ºå¤šäººä¼šè¯å¿«ç…§ï¼ˆåŒ…å«å‚ä¸è€…å’Œæ¶ˆæ¯ï¼‰
   */
  async getMultiRoleSession(sessionId: string): Promise<MultiRoleSession | null> {
    try {
      const sessions = await this.getSessions();
      const baseSession = sessions.find(s => s.id === sessionId);

      if (!baseSession) {
        Logger.warn('SessionManager', `æœªæ‰¾åˆ°ä¼šè¯ç”¨äºç”Ÿæˆå¤šäººä¼šè¯å¿«ç…§: ${sessionId}`);
        return null;
      }

      const messages = await this.getSessionMessages(sessionId);
      const participants = this.buildParticipantSnapshot(
        messages,
        isMultiRoleSession(baseSession) ? (baseSession as MultiRoleSession).participants : []
      );

      const multiSession = new MultiRoleSession(
        baseSession.name,
        participants,
        messages,
        baseSession.systemPromptId,
        baseSession.roleId,
        baseSession.id
      );
      multiSession.createdAt = baseSession.createdAt;
      multiSession.updatedAt = baseSession.updatedAt;
      multiSession.messageCount = messages.length;

      return multiSession;
    } catch (error) {
      Logger.error('SessionManager', `è·å–å¤šäººä¼šè¯å¤±è´¥: ${error}`);
      return null;
    }
  }

  /**
   * ä¿å­˜å¤šäººä¼šè¯ï¼ˆåŒæ­¥æ¶ˆæ¯ä¸å‚ä¸è€…å¿«ç…§ï¼‰
   */
  async saveMultiRoleSession(session: MultiRoleSession): Promise<void> {
    try {
      const messages = session.messages || [];
      const participants = session.participants || [];

      const saveOptions: SaveSessionMessagesOptions = {
        participants,
        name: session.name
      };
      await this.saveSessionMessages(session.id, messages, saveOptions);

      Logger.info('SessionManager', `ä¿å­˜å¤šäººä¼šè¯æˆåŠŸ: ${session.id}`);
    } catch (error) {
      Logger.error('SessionManager', `ä¿å­˜å¤šäººä¼šè¯å¤±è´¥: ${error}`);
      throw error as Error;
    }
  }

  /**
   * è·å–ä¼šè¯å‚ä¸è€…åˆ—è¡¨
   */
  async getSessionParticipants(sessionId: string): Promise<SessionParticipant[]> {
    try {
      const sessions = await this.getSessions();
      const session = sessions.find(s => s.id === sessionId);

      if (!session) {
        Logger.warn('SessionManager', `æœªæ‰¾åˆ°ä¼šè¯å‚ä¸è€…: ${sessionId}`);
        return [];
      }

      if (isMultiRoleSession(session)) {
        return this.normalizeParticipants((session as MultiRoleSession).participants);
      }

      const messages = await this.getSessionMessages(sessionId);
      return this.buildParticipantSnapshot(messages);
    } catch (error) {
      Logger.error('SessionManager', `è·å–ä¼šè¯å‚ä¸è€…å¤±è´¥: ${error}`);
      return [];
    }
  }

  /**
   * æ›´æ–°ä¼šè¯å‚ä¸è€…ä¿¡æ¯ï¼ˆä¸è§¦å‘æ¶ˆæ¯å˜æ›´ï¼‰
   */
  async updateSessionParticipants(
    sessionId: string,
    participants: Array<SessionParticipant | SessionParticipantData>
  ): Promise<void> {
    try {
      const updateOptions: UpdateSessionInfoOptions = { participants };
      await this.updateSessionInfo(sessionId, undefined, updateOptions);
      Logger.debug('SessionManager', `æ›´æ–°ä¼šè¯å‚ä¸è€…: ${sessionId}, æ•°é‡: ${participants.length}`);
    } catch (error) {
      Logger.error('SessionManager', `æ›´æ–°ä¼šè¯å‚ä¸è€…å¤±è´¥: ${error}`);
      throw error as Error;
    }
  }

  /**
   * æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ›å»ºé»˜è®¤ä¼šè¯
   */
  async ensureDefaultSession(): Promise<Session> {
    try {
      let sessions = await this.getSessions();
      
      // æ•°æ®è¿ç§»ï¼šä¸ºæ—§ä¼šè¯æ·»åŠ systemPromptIdå­—æ®µ
      await this.migrateSessionsData(sessions);
      
      // é‡æ–°è·å–è¿ç§»åçš„ä¼šè¯
      sessions = await this.getSessions();
      
      if (sessions.length === 0) {
        Logger.info('SessionManager', 'æ²¡æœ‰ä¼šè¯ï¼Œåˆ›å»ºé»˜è®¤ä¼šè¯');
        return await this.createNewSession();
      }

      // æ£€æŸ¥æ˜¯å¦æœ‰å½“å‰ä¼šè¯
      const currentSessionId = await this.getCurrentSessionId();
      if (!currentSessionId || !sessions.find(s => s.id === currentSessionId)) {
        // è®¾ç½®ç¬¬ä¸€ä¸ªä¼šè¯ä¸ºå½“å‰ä¼šè¯
        await this.setCurrentSession(sessions[0].id);
        Logger.info('SessionManager', `è®¾ç½®é»˜è®¤å½“å‰ä¼šè¯: ${sessions[0].id}`);
      }

      return sessions[0];

    } catch (error) {
      Logger.error('SessionManager', `ç¡®ä¿é»˜è®¤ä¼šè¯å¤±è´¥: ${error}`);
      throw error as Error;
    }
  }

  /**
   * æ•°æ®è¿ç§»ï¼šä¸ºæ—§ä¼šè¯æ·»åŠ systemPromptIdå’ŒroleIdå­—æ®µ
   */
  private async migrateSessionsData(sessions: Session[]): Promise<void> {
    try {
      let needsMigration = false;

      // æ£€æŸ¥æ˜¯å¦éœ€è¦è¿ç§»
      for (const session of sessions) {
        if (session.systemPromptId === undefined || session.roleId === undefined) {
          needsMigration = true;
          break;
        }
      }

      if (!needsMigration) {
        Logger.debug('SessionManager', 'ä¼šè¯æ•°æ®å·²æ˜¯æœ€æ–°æ ¼å¼ï¼Œæ— éœ€è¿ç§»');
        return;
      }

      Logger.info('SessionManager', `å¼€å§‹è¿ç§»ä¼šè¯æ•°æ®ï¼Œå…± ${sessions.length} ä¸ªä¼šè¯`);

      // ä¸ºæ¯ä¸ªä¼šè¯è®¾ç½®é»˜è®¤å­—æ®µ
      for (const session of sessions) {
        let migrated = false;

        // è¿ç§»systemPromptId
        if (session.systemPromptId === undefined) {
          session.systemPromptId = null;
          migrated = true;
        }

        // è¿ç§»roleId - å¦‚æœæœ‰systemPromptIdä¸”å¯¹åº”çš„æç¤ºè¯æ˜¯è§’è‰²ï¼Œåˆ™è®¾ç½®roleId
        if (session.roleId === undefined && session.systemPromptId) {
          const prompts = await AppStorage.getSystemPrompts();
          const prompt = prompts.find(p => p.id === session.systemPromptId);
          if (prompt && prompt.isRole) {
            session.roleId = session.systemPromptId; // è®¾ç½®roleIdä¸ºè§’è‰²ID
          } else {
            session.roleId = undefined; // éè§’è‰²ä¼šè¯ä¸è®¾ç½®roleId
          }
          migrated = true;
        } else if (session.roleId === undefined) {
          session.roleId = undefined; // æ˜ç¡®è®¾ç½®ä¸ºundefined
          migrated = true;
        }

        if (migrated) {
          await AppStorage.saveSession(session);
          Logger.debug('SessionManager', `è¿ç§»ä¼šè¯: ${session.id} -> systemPromptId: ${session.systemPromptId}, roleId: ${session.roleId || 'æ— '}`);
        }
      }

      Logger.info('SessionManager', 'ä¼šè¯æ•°æ®è¿ç§»å®Œæˆ');

    } catch (error) {
      Logger.error('SessionManager', `ä¼šè¯æ•°æ®è¿ç§»å¤±è´¥: ${error}`);
    }
  }

  /**
   * åˆ‡æ¢åˆ°æŒ‡å®šä¼šè¯
   */
  async switchToSession(sessionId: string): Promise<Session | null> {
    try {
      const sessions = await this.getSessions();
      const targetSession = sessions.find(s => s.id === sessionId);
      
      if (!targetSession) {
        Logger.warn('SessionManager', `ä¼šè¯ä¸å­˜åœ¨: ${sessionId}`);
        return null;
      }

      await this.setCurrentSession(sessionId);
      Logger.info('SessionManager', `åˆ‡æ¢åˆ°ä¼šè¯: ${sessionId} - ${targetSession.name}`);
      
      return targetSession;

    } catch (error) {
      Logger.error('SessionManager', `åˆ‡æ¢ä¼šè¯å¤±è´¥: ${error}`);
      return null;
    }
  }

  /**
   * æœç´¢ä¼šè¯ - æ ¹æ®å…³é”®è¯æœç´¢ä¼šè¯æ ‡é¢˜å’Œæ¶ˆæ¯å†…å®¹
   */
  async searchSessions(query: string): Promise<Session[]> {
    try {
      Logger.info('SessionManager', `searchSessionsè¢«è°ƒç”¨ï¼ŒåŸå§‹æŸ¥è¯¢: "${query}"`);

      if (!query || !query.trim()) {
        // å¦‚æœæœç´¢è¯ä¸ºç©ºï¼Œè¿”å›æ‰€æœ‰ä¼šè¯
        Logger.info('SessionManager', 'æœç´¢è¯ä¸ºç©ºï¼Œè¿”å›æ‰€æœ‰ä¼šè¯');
        return await this.getSessions();
      }

      const lowerCaseQuery = query.toLowerCase().trim();
      Logger.info('SessionManager', `æœç´¢ä¼šè¯ï¼Œå…³é”®è¯: "${lowerCaseQuery}"`);

      // è·å–æ‰€æœ‰ä¼šè¯
      const allSessions = await this.getSessions();
      Logger.info('SessionManager', `æ€»å…±æœ‰ ${allSessions.length} ä¸ªä¼šè¯`);

      if (allSessions.length === 0) {
        Logger.warn('SessionManager', 'æ²¡æœ‰æ‰¾åˆ°ä»»ä½•ä¼šè¯');
        return [];
      }

      const matchedSessions: Session[] = [];
      let totalMessagesChecked = 0;
      let validMessagesFound = 0;
      let invalidMessagesFound = 0;

      // éå†æ¯ä¸ªä¼šè¯è¿›è¡Œæ£€æŸ¥
      for (let i = 0; i < allSessions.length; i++) {
        const session = allSessions[i];
        Logger.debug('SessionManager', `æ£€æŸ¥ä¼šè¯ ${i + 1}/${allSessions.length}: ${session.name} (ID: ${session.id})`);

        // 1. æ£€æŸ¥ä¼šè¯æ ‡é¢˜
        const sessionNameLower = session.name.toLowerCase();
        const titleMatch = sessionNameLower.includes(lowerCaseQuery);

        if (titleMatch) {
          Logger.info('SessionManager', `âœ… ä¼šè¯æ ‡é¢˜åŒ¹é…: "${session.name}"`);
          matchedSessions.push(session);
          continue; // åŒ¹é…åˆ°æ ‡é¢˜ï¼Œæ— éœ€æ£€æŸ¥æ¶ˆæ¯å†…å®¹
        }

        // 2. æ£€æŸ¥ä¼šè¯å†…çš„æ¶ˆæ¯å†…å®¹
        try {
          const messages = await this.getSessionMessages(session.id);
          Logger.debug('SessionManager', `ä¼šè¯ ${session.id} æœ‰ ${messages.length} æ¡æ¶ˆæ¯`);
          totalMessagesChecked += messages.length;

          let messageMatchFound = false;
          let sessionValidMessages = 0;
          let sessionInvalidMessages = 0;

          for (let j = 0; j < messages.length && !messageMatchFound; j++) {
            const message = messages[j];

            // éªŒè¯æ¶ˆæ¯æ•°æ®å®Œæ•´æ€§
            if (!message.content) {
              sessionInvalidMessages++;
              invalidMessagesFound++;
              Logger.warn('SessionManager', `ä¼šè¯ ${session.id} æ¶ˆæ¯ ${j} contentä¸ºç©º: ${message.id}`);
              continue;
            }

            if (typeof message.content !== 'string') {
              sessionInvalidMessages++;
              invalidMessagesFound++;
              Logger.warn('SessionManager', `ä¼šè¯ ${session.id} æ¶ˆæ¯ ${j} contentç±»å‹é”™è¯¯: ${typeof message.content}`);
              continue;
            }

            const trimmedContent = message.content.trim();
            if (!trimmedContent) {
              sessionInvalidMessages++;
              invalidMessagesFound++;
              Logger.debug('SessionManager', `ä¼šè¯ ${session.id} æ¶ˆæ¯ ${j} contentä¸ºç©ºå­—ç¬¦ä¸²`);
              continue;
            }

            sessionValidMessages++;
            validMessagesFound++;

            // æ‰§è¡Œå†…å®¹æœç´¢
            const messageContentLower = trimmedContent.toLowerCase();
            const contentMatch = messageContentLower.includes(lowerCaseQuery);

            if (contentMatch) {
              Logger.info('SessionManager', `âœ… æ¶ˆæ¯å†…å®¹åŒ¹é…: ä¼šè¯="${session.name}", æ¶ˆæ¯="${trimmedContent.substring(0, 50)}..."`);
              matchedSessions.push(session);
              messageMatchFound = true;
            }
          }

          if (sessionInvalidMessages > 0) {
            Logger.warn('SessionManager', `ä¼šè¯ ${session.id} æœ‰ ${sessionInvalidMessages} æ¡æ— æ•ˆæ¶ˆæ¯ï¼Œ${sessionValidMessages} æ¡æœ‰æ•ˆæ¶ˆæ¯`);
          }

        } catch (error) {
          Logger.error('SessionManager', `è·å–ä¼šè¯ ${session.id} çš„æ¶ˆæ¯å¤±è´¥ï¼Œè·³è¿‡æ¶ˆæ¯å†…å®¹æœç´¢: ${error}`);
        }
      }

      // è¾“å‡ºæœç´¢ç»Ÿè®¡ä¿¡æ¯
      Logger.info('SessionManager', `ğŸ“Š æœç´¢ç»Ÿè®¡:`);
      Logger.info('SessionManager', `  - æœç´¢å…³é”®è¯: "${lowerCaseQuery}"`);
      Logger.info('SessionManager', `  - æ£€æŸ¥ä¼šè¯æ•°: ${allSessions.length}`);
      Logger.info('SessionManager', `  - æ£€æŸ¥æ¶ˆæ¯æ•°: ${totalMessagesChecked}`);
      Logger.info('SessionManager', `  - æœ‰æ•ˆæ¶ˆæ¯æ•°: ${validMessagesFound}`);
      Logger.info('SessionManager', `  - æ— æ•ˆæ¶ˆæ¯æ•°: ${invalidMessagesFound}`);
      Logger.info('SessionManager', `  - åŒ¹é…ä¼šè¯æ•°: ${matchedSessions.length}`);

      if (invalidMessagesFound > 0) {
        Logger.warn('SessionManager', `âš ï¸ å‘ç° ${invalidMessagesFound} æ¡æ— æ•ˆæ¶ˆæ¯ï¼Œå»ºè®®è¿è¡Œæ•°æ®ä¿®å¤`);
      }

      Logger.info('SessionManager', `ğŸ‰ æœç´¢å®Œæˆï¼Œæ‰¾åˆ° ${matchedSessions.length} ä¸ªåŒ¹é…ä¼šè¯`);
      return matchedSessions;

    } catch (error) {
      Logger.error('SessionManager', `æœç´¢ä¼šè¯å¤±è´¥: ${error}`);
      return [];
    }
  }

  /**
   * ä¿®å¤æ‰€æœ‰ä¼šè¯çš„æ¶ˆæ¯æ•°æ®
   */
  async repairAllSessionMessages(): Promise<void> {
    try {
      Logger.info('SessionManager', 'ğŸ”§ å¼€å§‹ä¿®å¤æ‰€æœ‰ä¼šè¯çš„æ¶ˆæ¯æ•°æ®');

      const allSessions = await this.getSessions();
      let repairedSessionCount = 0;
      let totalRepairedMessages = 0;

      for (const session of allSessions) {
        try {
          Logger.debug('SessionManager', `ä¿®å¤ä¼šè¯: ${session.name} (${session.id})`);

          // è·å–ä¼šè¯æ¶ˆæ¯ï¼Œè¿™ä¸ªè¿‡ç¨‹ä¸­ä¼šè‡ªåŠ¨ä¿®å¤æ•°æ®
          const messages = await this.getSessionMessages(session.id);

          // æ£€æŸ¥æ˜¯å¦æœ‰æ— æ•ˆæ¶ˆæ¯
          let invalidCount = 0;
          const validMessages = messages.filter(msg => {
            if (!msg.content || typeof msg.content !== 'string') {
              invalidCount++;
              return false;
            }
            return true;
          });

          if (invalidCount > 0 || validMessages.length !== messages.length) {
            // é‡æ–°ä¿å­˜æœ‰æ•ˆæ¶ˆæ¯
            await this.saveSessionMessages(session.id, validMessages);
            repairedSessionCount++;
            totalRepairedMessages += invalidCount;

            Logger.info('SessionManager', `âœ… ä¿®å¤ä¼šè¯ ${session.name}: ç§»é™¤ ${invalidCount} æ¡æ— æ•ˆæ¶ˆæ¯`);
          }

        } catch (error) {
          Logger.error('SessionManager', `ä¿®å¤ä¼šè¯ ${session.id} å¤±è´¥: ${error}`);
        }
      }

      Logger.info('SessionManager', `ğŸ‰ æ•°æ®ä¿®å¤å®Œæˆ:`);
      Logger.info('SessionManager', `  - æ£€æŸ¥ä¼šè¯æ•°: ${allSessions.length}`);
      Logger.info('SessionManager', `  - ä¿®å¤ä¼šè¯æ•°: ${repairedSessionCount}`);
      Logger.info('SessionManager', `  - ä¿®å¤æ¶ˆæ¯æ•°: ${totalRepairedMessages}`);

    } catch (error) {
      Logger.error('SessionManager', `ä¿®å¤ä¼šè¯æ•°æ®å¤±è´¥: ${error}`);
      throw new Error(`ä¿®å¤ä¼šè¯æ•°æ®å¤±è´¥: ${error}`);
    }
  }

  /**
   * è¯Šæ–­ä¼šè¯æ•°æ®è´¨é‡
   */
  async diagnoseSessionDataQuality(): Promise<SessionDataQuality> {
    try {
      Logger.info('SessionManager', 'ğŸ” å¼€å§‹è¯Šæ–­ä¼šè¯æ•°æ®è´¨é‡');

      const allSessions = await this.getSessions();
      let totalMessages = 0;
      let validMessages = 0;
      let invalidMessages = 0;
      let emptyContentMessages = 0;
      const sessionsWithIssues: string[] = [];

      for (const session of allSessions) {
        try {
          const messages = await AppStorage.getSessionMessages(session.id);
          totalMessages += messages.length;

          let sessionHasIssues = false;

          for (const message of messages) {
            if (!message.content) {
              invalidMessages++;
              sessionHasIssues = true;
            } else if (typeof message.content !== 'string') {
              invalidMessages++;
              sessionHasIssues = true;
            } else if (!message.content.trim()) {
              emptyContentMessages++;
              sessionHasIssues = true;
            } else {
              validMessages++;
            }
          }

          if (sessionHasIssues) {
            sessionsWithIssues.push(`${session.name} (${session.id})`);
          }

        } catch (error) {
          Logger.error('SessionManager', `è¯Šæ–­ä¼šè¯ ${session.id} å¤±è´¥: ${error}`);
          sessionsWithIssues.push(`${session.name} (${session.id}) - è¯»å–å¤±è´¥`);
        }
      }

      const result: SessionDataQuality = {
        totalSessions: allSessions.length,
        totalMessages,
        validMessages,
        invalidMessages,
        emptyContentMessages,
        sessionsWithIssues
      };

      Logger.info('SessionManager', `ğŸ“Š æ•°æ®è´¨é‡è¯Šæ–­ç»“æœ:`);
      Logger.info('SessionManager', `  - ä¼šè¯æ€»æ•°: ${result.totalSessions}`);
      Logger.info('SessionManager', `  - æ¶ˆæ¯æ€»æ•°: ${result.totalMessages}`);
      Logger.info('SessionManager', `  - æœ‰æ•ˆæ¶ˆæ¯: ${result.validMessages}`);
      Logger.info('SessionManager', `  - æ— æ•ˆæ¶ˆæ¯: ${result.invalidMessages}`);
      Logger.info('SessionManager', `  - ç©ºå†…å®¹æ¶ˆæ¯: ${result.emptyContentMessages}`);
      Logger.info('SessionManager', `  - æœ‰é—®é¢˜çš„ä¼šè¯: ${result.sessionsWithIssues.length}`);

      return result;

    } catch (error) {
      Logger.error('SessionManager', `è¯Šæ–­ä¼šè¯æ•°æ®è´¨é‡å¤±è´¥: ${error}`);
      throw new Error(`è¯Šæ–­ä¼šè¯æ•°æ®è´¨é‡å¤±è´¥: ${error}`);
    }
  }

  /**
   * è·å–ä¼šè¯ç»Ÿè®¡ä¿¡æ¯
   */
  async getSessionStats(): Promise<SessionStats> {
    try {
      const sessions = await this.getSessions();
      const currentSessionId = await this.getCurrentSessionId();

      const stats: SessionStats = {
        totalSessions: sessions.length,
        maxSessions: this.MAX_SESSIONS,
        currentSessionId: currentSessionId
      };
      return stats;
    } catch (error) {
      Logger.error('SessionManager', `è·å–ä¼šè¯ç»Ÿè®¡å¤±è´¥: ${error}`);
      const errorStats: SessionStats = {
        totalSessions: 0,
        maxSessions: this.MAX_SESSIONS,
        currentSessionId: null
      };
      return errorStats;
    }
  }
}
