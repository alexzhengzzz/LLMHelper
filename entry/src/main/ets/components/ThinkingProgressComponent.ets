/**
 * æ·±åº¦æ€è€ƒè¿›åº¦æŒ‡ç¤ºå™¨ç»„ä»¶
 */

import { ThinkingStatus, StepStatus, ThinkingStep } from '../models/ChatModels';

@ComponentV2
export struct ThinkingProgressComponent {
  @Param @Require thinkingSteps: ThinkingStep[];
  @Param @Require thinkingStatus: ThinkingStatus;
  @Param progressSize: 'small' | 'medium' | 'large' = 'medium';
  @Param showText: boolean = true;
  @Param showPercentage: boolean = false;
  @Param animated: boolean = true;

  @Local private animationRotation: number = 0;
  private animationTimer: number = -1;

  aboutToAppear() {
    if (this.animated && this.isProcessing()) {
      this.startAnimation();
    }
  }

  aboutToDisappear() {
    this.stopAnimation();
  }

  build() {
    if (this.thinkingStatus === ThinkingStatus.IDLE) {
      Blank();
    } else {
      Column({ space: this.getSpacing() }) {
        // ä¸»è¦è¿›åº¦æŒ‡ç¤ºå™¨
        this.buildMainIndicator()
        
        // æ–‡å­—æè¿°
        if (this.showText) {
          this.buildTextIndicator()
        }
        
        // è¯¦ç»†æ­¥éª¤è¿›åº¦
        if (this.progressSize !== 'small' && this.thinkingSteps.length > 0) {
          this.buildStepProgress()
        }
      }
      .justifyContent(FlexAlign.Center)
      .alignItems(HorizontalAlign.Center)
    }
  }

  @Builder
  private buildMainIndicator() {
    if (this.thinkingStatus === ThinkingStatus.COMPLETED) {
      // å®ŒæˆçŠ¶æ€ - æ˜¾ç¤ºæˆåŠŸå›¾æ ‡
      this.buildSuccessIndicator()
    } else if (this.thinkingStatus === ThinkingStatus.FAILED) {
      // å¤±è´¥çŠ¶æ€ - æ˜¾ç¤ºé”™è¯¯å›¾æ ‡
      this.buildErrorIndicator()
    } else if (this.thinkingStatus === ThinkingStatus.CANCELLED) {
      // å–æ¶ˆçŠ¶æ€ - æ˜¾ç¤ºå–æ¶ˆå›¾æ ‡
      this.buildCancelledIndicator()
    } else {
      // è¿›è¡Œä¸­çŠ¶æ€ - æ˜¾ç¤ºè¿›åº¦åœ†çŽ¯
      this.buildProgressRing()
    }
  }

  @Builder
  private buildProgressRing() {
    Stack() {
      // èƒŒæ™¯åœ†çŽ¯
      Circle()
        .width(this.getMainSize())
        .height(this.getMainSize())
        .fill(Color.Transparent)
        .stroke('#E5E7EB')
        .strokeWidth(this.getStrokeWidth())
      
      // è¿›åº¦åœ†çŽ¯
      Circle()
        .width(this.getMainSize())
        .height(this.getMainSize())
        .fill(Color.Transparent)
        .stroke(this.getProgressColor())
        .strokeWidth(this.getStrokeWidth())
        .strokeDashArray(this.getProgressDashArray())
        .rotate({ angle: this.animationRotation })
        .animation(this.animated ? {
          duration: 1000,
          curve: Curve.Linear,
          iterations: -1
        } : undefined)
      
      // ä¸­å¿ƒå›¾æ ‡
      Text(this.getCenterIcon())
        .fontSize(this.getIconSize())
        .fontColor(this.getProgressColor())
    }
  }

  @Builder
  private buildSuccessIndicator() {
    Stack() {
      Circle()
        .width(this.getMainSize())
        .height(this.getMainSize())
        .fill('#F0FDF4')
        .border({ width: this.getStrokeWidth(), color: '#10B981' })
      
      Text('âœ…')
        .fontSize(this.getIconSize())
    }
  }

  @Builder
  private buildErrorIndicator() {
    Stack() {
      Circle()
        .width(this.getMainSize())
        .height(this.getMainSize())
        .fill('#FEF2F2')
        .border({ width: this.getStrokeWidth(), color: '#DC2626' })
      
      Text('âŒ')
        .fontSize(this.getIconSize())
    }
  }

  @Builder
  private buildCancelledIndicator() {
    Stack() {
      Circle()
        .width(this.getMainSize())
        .height(this.getMainSize())
        .fill('#F9FAFB')
        .border({ width: this.getStrokeWidth(), color: '#6B7280' })
      
      Text('â¹ï¸')
        .fontSize(this.getIconSize())
    }
  }

  @Builder
  private buildTextIndicator() {
    Column({ space: 2 }) {
      Text(this.getStatusText())
        .fontSize(this.getTextSize())
        .fontColor('#2D3142')
        .fontWeight(500)
        .textAlign(TextAlign.Center)
      
      if (this.showPercentage && this.isProcessing()) {
        Text(this.getPercentageText())
          .fontSize(this.getSubTextSize())
          .fontColor('#666')
          .textAlign(TextAlign.Center)
      }
    }
  }

  @Builder
  private buildStepProgress() {
    Row({ space: 4 }) {
      ForEach(this.thinkingSteps, (step: ThinkingStep, index: number) => {
        this.buildStepDot(step, index)
      })
    }
    .justifyContent(FlexAlign.Center)
  }

  @Builder
  private buildStepDot(step: ThinkingStep, index: number) {
    Circle()
      .width(this.getDotSize())
      .height(this.getDotSize())
      .fill(this.getStepDotColor(step.status))
      .border({
        width: 1,
        color: this.getStepDotBorderColor(step.status)
      })
      .animation(this.animated ? {
        duration: 300,
        curve: Curve.EaseInOut
      } : undefined)
  }

  // å·¥å…·æ–¹æ³•
  private getMainSize(): number {
    switch (this.progressSize) {
      case 'small': return 24;
      case 'medium': return 32;
      case 'large': return 48;
      default: return 32;
    }
  }

  private getStrokeWidth(): number {
    switch (this.progressSize) {
      case 'small': return 2;
      case 'medium': return 3;
      case 'large': return 4;
      default: return 3;
    }
  }

  private getIconSize(): number {
    switch (this.progressSize) {
      case 'small': return 12;
      case 'medium': return 16;
      case 'large': return 24;
      default: return 16;
    }
  }

  private getTextSize(): number {
    switch (this.progressSize) {
      case 'small': return 11;
      case 'medium': return 13;
      case 'large': return 15;
      default: return 13;
    }
  }

  private getSubTextSize(): number {
    switch (this.progressSize) {
      case 'small': return 9;
      case 'medium': return 11;
      case 'large': return 13;
      default: return 11;
    }
  }

  private getDotSize(): number {
    switch (this.progressSize) {
      case 'small': return 6;
      case 'medium': return 8;
      case 'large': return 10;
      default: return 8;
    }
  }

  private getSpacing(): number {
    switch (this.progressSize) {
      case 'small': return 4;
      case 'medium': return 6;
      case 'large': return 8;
      default: return 6;
    }
  }

  private getProgressColor(): string {
    switch (this.thinkingStatus) {
      case ThinkingStatus.ANALYZING: return '#3B82F6';
      case ThinkingStatus.THINKING: return '#8B5CF6';
      case ThinkingStatus.VERIFYING: return '#10B981';
      case ThinkingStatus.INTEGRATING: return '#F59E0B';
      default: return '#4A90E2';
    }
  }

  private getCenterIcon(): string {
    switch (this.thinkingStatus) {
      case ThinkingStatus.ANALYZING: return 'ðŸ”';
      case ThinkingStatus.THINKING: return 'ðŸ§ ';
      case ThinkingStatus.VERIFYING: return 'âœ…';
      case ThinkingStatus.INTEGRATING: return 'ðŸŽ¯';
      default: return 'ðŸ’­';
    }
  }

  private getStatusText(): string {
    switch (this.thinkingStatus) {
      case ThinkingStatus.ANALYZING: return 'æ·±åº¦åˆ†æž';
      case ThinkingStatus.THINKING: return 'å¤šè§’åº¦æ€è€ƒ';
      case ThinkingStatus.VERIFYING: return 'æ‰¹åˆ¤éªŒè¯';
      case ThinkingStatus.INTEGRATING: return 'ç»¼åˆæ•´åˆ';
      case ThinkingStatus.COMPLETED: return 'æ€è€ƒå®Œæˆ';
      case ThinkingStatus.FAILED: return 'æ€è€ƒå¤±è´¥';
      case ThinkingStatus.CANCELLED: return 'å·²å–æ¶ˆ';
      default: return 'æ·±åº¦æ€è€ƒ';
    }
  }

  private getPercentageText(): string {
    const completed = this.thinkingSteps.filter(s => s.status === StepStatus.COMPLETED).length;
    const total = this.thinkingSteps.length;
    const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;
    return `${percentage}%`;
  }

  private getProgressDashArray(): number[] {
    const completed = this.thinkingSteps.filter(s => s.status === StepStatus.COMPLETED).length;
    const total = this.thinkingSteps.length;
    
    if (total === 0) {
      return [0, 100]; // æ˜¾ç¤ºæ—‹è½¬åŠ¨ç”»
    }
    
    const circumference = Math.PI * (this.getMainSize() - this.getStrokeWidth());
    const progress = completed / total;
    const dashLength = circumference * progress;
    const gapLength = circumference * (1 - progress);
    
    return [dashLength, gapLength];
  }

  private getStepDotColor(status: StepStatus): string {
    switch (status) {
      case StepStatus.COMPLETED: return '#10B981';
      case StepStatus.PROCESSING: return '#4A90E2';
      case StepStatus.FAILED: return '#DC2626';
      default: return '#E5E7EB';
    }
  }

  private getStepDotBorderColor(status: StepStatus): string {
    switch (status) {
      case StepStatus.COMPLETED: return '#059669';
      case StepStatus.PROCESSING: return '#2563EB';
      case StepStatus.FAILED: return '#B91C1C';
      default: return '#D1D5DB';
    }
  }

  private isProcessing(): boolean {
    return this.thinkingStatus === ThinkingStatus.ANALYZING ||
           this.thinkingStatus === ThinkingStatus.THINKING ||
           this.thinkingStatus === ThinkingStatus.VERIFYING ||
           this.thinkingStatus === ThinkingStatus.INTEGRATING;
  }

  private startAnimation(): void {
    this.stopAnimation();
    this.animationTimer = setInterval(() => {
      this.animationRotation += 90;
      if (this.animationRotation >= 360) {
        this.animationRotation = 0;
      }
    }, 250);
  }

  private stopAnimation(): void {
    if (this.animationTimer !== -1) {
      clearInterval(this.animationTimer);
      this.animationTimer = -1;
    }
  }
}