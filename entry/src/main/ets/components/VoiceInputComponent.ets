import { SpeechRecognitionService } from '../services/SpeechRecognitionService';
import { AppContext } from '../utils/AppContext';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { vibrator } from '@kit.SensorServiceKit';
import { audio } from '@kit.AudioKit';
import { ThemeManager } from '../utils/ThemeManager';
import { Logger } from '../utils/Logger';
import { Constants, PromptTemplate } from '../utils/Constants';
import { PromptRecommendationManager } from '../utils/PromptRecommendationManager';

// å¯¼å…¥åŸºç¡€åŠ¨ç”»ç³»ç»Ÿ
import { 
  BasicAnimations, 
  AnimationConfigManager
} from '../animations';

/**
 * è¯­éŸ³è¯†åˆ«çŠ¶æ€
 */
export enum VoiceRecognitionState {
  IDLE = 'idle',           // ç©ºé—²çŠ¶æ€
  RECORDING = 'recording', // å½•éŸ³ä¸­
  PROCESSING = 'processing', // å¤„ç†ä¸­
  ERROR = 'error'         // é”™è¯¯çŠ¶æ€
}

/**
 * è¾“å…¥æ¨¡å¼
 */
export enum InputMode {
  TEXT = 'text',
  VOICE = 'voice'
}

export interface VoiceOverlayHint {
  text: string;
  tone: 'default' | 'warning' | 'processing';
}

/**
 * è§¦æ‘¸ç‚¹ä¿¡æ¯æ¥å£
 */
interface TouchInfo {
  globalY?: number;
  screenY?: number;
  windowY?: number;
  y?: number;
}

/**
 * è§¦æ‘¸äº‹ä»¶æ‰©å±•æ¥å£
 */
interface ExtendedTouchEvent {
  touches?: Array<TouchInfo>;
  changedTouches?: Array<TouchInfo>;
}

const DEFAULT_WAVEFORM: number[] = [0.3, 0.5, 0.8, 0.4, 0.7, 0.2, 0.9, 0.6];

/**
 * è¯­éŸ³è¾“å…¥ç»„ä»¶å±æ€§
 */
@ComponentV2
export struct VoiceInputComponent {
  @Param onVoiceResult: (text: string) => void = () => {};  // è¯­éŸ³è¯†åˆ«ç»“æœå›è°ƒ
  @Param onStateChange: (state: VoiceRecognitionState) => void = () => {}; // çŠ¶æ€å˜åŒ–å›è°ƒ
  @Param onSmartPromptTriggered?: (prompt: string) => void = () => {}; // æ™ºèƒ½promptè§¦å‘å›è°ƒ
  @Param onInputModeChange: (mode: InputMode) => void = () => {}; // è¾“å…¥æ¨¡å¼å˜åŒ–å›è°ƒ
  @Param onHintChange: (hint: VoiceOverlayHint | null) => void = () => {}; // ä¸­å¤®æç¤ºå›è°ƒ
  
  @Local private currentInputMode: InputMode = InputMode.TEXT;
  @Local private isRecording: boolean = false;
  @Local private showCancelHint: boolean = false;
  @Local private recognitionState: VoiceRecognitionState = VoiceRecognitionState.IDLE;
  @Local private errorText: string = '';
  @Local private animationScale: number = 1.0;
  @Local private pulseOpacity: number = 0.3;
  @Local private rotationAngle: number = 0;
  @Local private isPressed: boolean = false;
  @Local private waveAmplitudes: number[] = [...DEFAULT_WAVEFORM];
  @Local private isDarkMode: boolean = false;
  @Local private speechService: SpeechRecognitionService = new SpeechRecognitionService();
  @Local private isGestureRecording: boolean = false;
  @Local private isSwipeToCancel: boolean = false;
  @Local private dragDistance: number = 0;
  private themeManager: ThemeManager = ThemeManager.getInstance();
  
  // ç®€åŒ–åŠ¨ç”»çŠ¶æ€
  @Local private breathingScale: number = 1.0;
  @Local private energyLevel: number = 0.0;
  
  // è¯­éŸ³æç¤ºç›¸å…³
  @Local private showVoiceTips: boolean = false;
  @Local private voiceTipText: string = '';
  @Local private tipRotationIndex: number = 0;
  private longPressTimer: number = 0;
  private tipRotationTimer: number = 0;
  private tipAutoHideTimer: number = 0;
  private touchStartY: number = 0;
  private isLongPressTriggered: boolean = false;
  private readonly longPressTriggerMs: number = 220;
  private readonly swipeCancelThreshold: number = 80;
  private recommendationManager: PromptRecommendationManager = PromptRecommendationManager.getInstance();
  private waveAnimationTimer: number = 0;
  private currentOverlayHint: VoiceOverlayHint | null = null;
  
  async aboutToAppear(): Promise<void> {
    hilog.info(0x0000, 'VoiceInputComponent', 'ç»„ä»¶åˆå§‹åŒ–å¼€å§‹');
    
    // åˆå§‹åŒ–åŠ¨ç”»ç³»ç»Ÿ
    AnimationConfigManager.getInstance().initialize();
    
    await this.themeManager.initialize();
    this.isDarkMode = this.themeManager.getDarkMode();
    
    // åˆå§‹åŒ–æ¨èç®¡ç†å™¨
    await this.recommendationManager.initialize();
    
    // æ·»åŠ ä¸»é¢˜å˜æ›´ç›‘å¬å™¨
    this.themeManager.addThemeListener((isDark: boolean) => {
      this.isDarkMode = isDark;
    });
    
    this.initializeSpeechService();
    this.startVoiceTipRotation();
    this.onInputModeChange(this.currentInputMode);
    this.notifyHintUpdate();
    hilog.info(0x0000, 'VoiceInputComponent', 'ç»„ä»¶åˆå§‹åŒ–å®Œæˆ');
  }

  aboutToDisappear(): void {
    hilog.info(0x0000, 'VoiceInputComponent', 'ç»„ä»¶é”€æ¯å¼€å§‹ï¼Œå½“å‰çŠ¶æ€: %{public}s', this.recognitionState);
    this.speechService.destroy();
    
    // æ¸…ç†å®šæ—¶å™¨
    if (this.longPressTimer > 0) {
      clearTimeout(this.longPressTimer);
    }
    if (this.tipRotationTimer > 0) {
      clearInterval(this.tipRotationTimer);
    }
    if (this.tipAutoHideTimer > 0) {
      clearTimeout(this.tipAutoHideTimer);
    }

    if (this.waveAnimationTimer > 0) {
      clearInterval(this.waveAnimationTimer);
      this.waveAnimationTimer = 0;
    }

    // ç§»é™¤ä¸»é¢˜ç›‘å¬å™¨
    this.themeManager.removeThemeListener((isDark: boolean) => {
      this.isDarkMode = isDark;
    });
    this.onHintChange(null);
    this.currentOverlayHint = null;
    hilog.info(0x0000, 'VoiceInputComponent', 'ç»„ä»¶é”€æ¯å®Œæˆ');
  }

  /**
   * åˆå§‹åŒ–è¯­éŸ³æœåŠ¡
   */
  private async initializeSpeechService(): Promise<void> {
    hilog.info(0x0000, 'VoiceInputComponent', 'å¼€å§‹åˆå§‹åŒ–è¯­éŸ³æœåŠ¡');
    
    try {
      // è·å–åº”ç”¨ä¸Šä¸‹æ–‡
      const context = AppContext.getInstance().getContext();
      hilog.info(0x0000, 'VoiceInputComponent', 'åº”ç”¨ä¸Šä¸‹æ–‡è·å–: %{public}s', context ? 'æˆåŠŸ' : 'å¤±è´¥');
      
      // è®¾ç½®å›è°ƒ
      this.speechService.setOnResult((text: string) => {
        hilog.info(0x0000, 'VoiceInputComponent', 'æ”¶åˆ°è¯­éŸ³è¯†åˆ«ç»“æœ: %{public}s', text);
        this.handleVoiceResultInternal(text);
      });

      this.speechService.setOnError((error: string) => {
        hilog.error(0x0000, 'VoiceInputComponent', 'æ”¶åˆ°è¯­éŸ³è¯†åˆ«é”™è¯¯: %{public}s', error);
        // ä¸ç›´æ¥æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯ï¼Œè€Œæ˜¯æ˜¾ç¤ºå‹å¥½çš„æç¤º
        Logger.error('VoiceInputComponent', `è¯­éŸ³è¯†åˆ«é”™è¯¯: ${error}`);
        // æä¾›è½»å¾®çš„è§¦è§‰åé¦ˆï¼Œè®©ç”¨æˆ·çŸ¥é“æœ‰é—®é¢˜å‘ç”Ÿ
        this.triggerHapticFeedback();
        // ä¸è®¾ç½®errorTextï¼Œè®©é”™è¯¯å¡ç‰‡ä¸æ˜¾ç¤º
        this.updateState(VoiceRecognitionState.IDLE); // ç›´æ¥å›åˆ°ç©ºé—²çŠ¶æ€
      });

      this.speechService.setOnStateChange((state: VoiceRecognitionState) => {
        hilog.info(0x0000, 'VoiceInputComponent', 'æ”¶åˆ°çŠ¶æ€å˜åŒ–: %{public}s -> %{public}s', this.recognitionState, state);
        this.updateState(state);
      });

      // åˆå§‹åŒ–æœåŠ¡
      const initialized = await this.speechService.init(context);
      if (initialized) {
        hilog.info(0x0000, 'VoiceInputComponent', 'è¯­éŸ³æœåŠ¡åˆå§‹åŒ–æˆåŠŸ');
      } else {
        hilog.error(0x0000, 'VoiceInputComponent', 'è¯­éŸ³æœåŠ¡åˆå§‹åŒ–å¤±è´¥');
        Logger.error('VoiceInputComponent', 'è¯­éŸ³æœåŠ¡åˆå§‹åŒ–å¤±è´¥');
        // ä¸æ˜¾ç¤ºé”™è¯¯å¡ç‰‡ï¼Œé™é»˜å¤„ç†
      }
    } catch (error) {
      hilog.error(0x0000, 'VoiceInputComponent', 'è¯­éŸ³æœåŠ¡åˆå§‹åŒ–å¼‚å¸¸: %{public}s', JSON.stringify(error));
      Logger.error('VoiceInputComponent', `è¯­éŸ³æœåŠ¡åˆå§‹åŒ–å¼‚å¸¸: ${JSON.stringify(error)}`);
      // ä¸æ˜¾ç¤ºé”™è¯¯å¡ç‰‡ï¼Œé™é»˜å¤„ç†
    }
  }
  
  build() {
    Column({ space: 8 }) {
      this.buildInputArea()
      if (this.recognitionState === VoiceRecognitionState.IDLE && this.showVoiceTips && this.voiceTipText) {
        this.buildVoiceTipCard()
      }
    }
    .width('100%')
    .alignItems(this.currentInputMode === InputMode.TEXT ? HorizontalAlign.End : HorizontalAlign.Center)
  }

  @Builder
  private buildInputArea() {
    if (this.currentInputMode === InputMode.TEXT) {
      this.buildTextModeTrigger()
    } else {
      this.buildVoiceModeContainer()
    }
  }

  @Builder
  private buildTextModeTrigger() {
    Button() {
      if (this.recognitionState === VoiceRecognitionState.PROCESSING) {
        this.buildProcessingIcon()
      } else {
        this.buildMicrophoneIcon()
      }
    }
    .width(this.getButtonWidth())
    .height(this.getButtonHeight())
    .backgroundColor(this.getButtonBackgroundColor())
    .fontColor(Color.White)
    .borderRadius(this.getButtonRadius())
    .scale({
      x: this.isPressed ? 0.95 : this.breathingScale,
      y: this.isPressed ? 0.95 : this.breathingScale
    })
    .animation({
      duration: BasicAnimations.QUICK_DURATION,
      curve: Curve.EaseInOut
    })
    .onClick(() => {
      this.handleMicButtonTap();
    })
  }

  @Builder
  private buildVoiceModeContainer() {
    Column({ space: 8 }) {
      Row({ space: 8 }) {
        this.buildKeyboardToggleButton()
        this.buildVoiceHoldButton()
      }
      .alignItems(VerticalAlign.Center)
      .width('100%')
    }
    .width('100%')
  }

  @Builder
  private buildKeyboardToggleButton() {
    Button() {
      this.buildKeyboardIcon()
    }
      .width(this.getButtonWidth())
      .height(this.getButtonHeight())
      .backgroundColor(this.getKeyboardButtonBackground())
      .borderRadius(this.getButtonRadius())
      .onClick(() => {
        this.switchToTextMode();
      })
  }

  @Builder
  private buildVoiceHoldButton() {
    Stack() {
      // èƒŒæ™¯
      Rect()
        .width('100%')
        .height(this.getVoiceHoldButtonHeight())
        .fill(this.getVoiceHoldBackgroundColor())
        .borderRadius(16)
        .border({
          width: 1,
          color: this.getVoiceHoldBorderColor()
        })

      // å†…éƒ¨å†…å®¹
      Column({ space: 6 }) {
        if (this.shouldShowWaveform()) {
          this.buildVoiceWaveform()
        }

        Text(this.getVoiceHoldMainText())
          .fontSize(14)
          .fontColor(this.getVoiceHoldTextColor())
          .fontWeight(FontWeight.Medium)

        if (this.shouldShowSubHint()) {
          Text(this.getVoiceHoldSubText())
            .fontSize(10)
            .fontColor(this.getVoiceHoldSubTextColor())
        }
      }
      .justifyContent(FlexAlign.Center)
      .alignItems(HorizontalAlign.Center)
      .height(this.getVoiceHoldButtonHeight())
    }
    .width('100%')
    .height(this.getVoiceHoldButtonHeight())
    .onTouch((event: TouchEvent) => {
      switch (event.type) {
        case TouchType.Down:
          this.handleGesturePressDown(event);
          break;
        case TouchType.Move:
          this.handleGestureMove(event);
          break;
        case TouchType.Up:
          this.handleGestureRelease(false);
          break;
        case TouchType.Cancel:
          this.handleGestureRelease(true);
          break;
        default:
          break;
      }
    })
  }

  @Builder
  private buildKeyboardIcon() {
    Column({ space: 2 }) {
      Rect()
        .width(18)
        .height(5)
        .borderRadius(2)
        .fill(this.getIconColor())

      Row({ space: 2 }) {
        ForEach([0, 1, 2, 3], (index: number) => {
          Rect()
            .width(3)
            .height(3)
            .borderRadius(1.5)
            .fill(this.getIconColor())
            .key(`key-${index}`)
        })
      }

      Rect()
        .width(18)
        .height(4)
        .borderRadius(2)
        .fill(this.getIconColor())
    }
  }

  @Builder
  private buildVoiceWaveform() {
    Row({ space: 3 }) {
      ForEach(this.waveAmplitudes, (amplitude: number, index: number) => {
        Rect()
          .width(4)
          .height(this.getWaveformBarHeight(amplitude, this.getWaveformMaxHeight()))
          .borderRadius(2)
          .fill(this.getWaveformColor())
          .opacity(this.showCancelHint ? 0.9 : 0.6 + amplitude * 0.4)
          .animation({
            duration: 240,
            curve: Curve.EaseInOut,
            iterations: -1,
            playMode: PlayMode.Alternate,
            delay: index * 40
          })
      })
    }
    .width('80%')
    .justifyContent(FlexAlign.Center)
    .height(this.getWaveformMaxHeight())
    .clip(true)
  }

  private getKeyboardButtonBackground(): string {
    return this.isDarkMode ? 'rgba(255, 255, 255, 0.08)' : '#F7F9FC';
  }

  private getVoiceHoldButtonHeight(): number {
    return 44;
  }

  private getVoiceHoldBackgroundColor(): string {
    if (this.showCancelHint) {
      return this.isDarkMode ? 'rgba(255, 77, 79, 0.18)' : '#FFECEC';
    }
    if (this.isRecording) {
      return this.isDarkMode ? 'rgba(116, 185, 255, 0.18)' : '#EEF6FF';
    }
    return this.isDarkMode ? 'rgba(255, 255, 255, 0.08)' : '#FFFFFF';
  }

  private getVoiceHoldBorderColor(): string {
    if (this.showCancelHint) {
      return this.isDarkMode ? 'rgba(255, 77, 79, 0.4)' : 'rgba(255, 77, 79, 0.5)';
    }
    if (this.isRecording) {
      return this.isDarkMode ? 'rgba(116, 185, 255, 0.5)' : 'rgba(116, 185, 255, 0.6)';
    }
    return this.isDarkMode ? 'rgba(255, 255, 255, 0.16)' : 'rgba(0, 0, 0, 0.08)';
  }

  private shouldShowWaveform(): boolean {
    return this.isRecording && !this.showCancelHint;
  }

  private getVoiceHoldMainText(): string {
    if (this.recognitionState === VoiceRecognitionState.PROCESSING) {
      return 'æ­£åœ¨è¯†åˆ«...';
    }
    if (this.showCancelHint) {
      return 'æ¾å¼€æ‰‹æŒ‡å–æ¶ˆå‘é€';
    }
    if (this.isGestureRecording) {
      return 'æ¾å¼€ å‘é€';
    }
    return 'æŒ‰ä½ è¯´è¯';
  }

  private shouldShowSubHint(): boolean {
    return this.recognitionState === VoiceRecognitionState.IDLE && !this.isGestureRecording && !this.isRecording;
  }

  private getVoiceHoldSubText(): string {
    if (this.showCancelHint) {
      return 'æ‹–åŠ¨åˆ°ä¸Šæ–¹å–æ¶ˆå½•éŸ³';
    }
    if (this.isGestureRecording) {
      return 'ä¸Šæ»‘å–æ¶ˆ';
    }
    return 'æ¾å¼€å‘é€ï¼Œä¸Šæ»‘å–æ¶ˆ';
  }

  private getVoiceHoldTextColor(): string {
    if (this.showCancelHint) {
      return '#FF4D4F';
    }
    if (this.recognitionState === VoiceRecognitionState.PROCESSING) {
      return this.isDarkMode ? '#CCCCCC' : '#666666';
    }
    return this.isDarkMode ? '#FFFFFF' : '#333333';
  }

  private getVoiceHoldSubTextColor(): string {
    if (this.showCancelHint) {
      return this.isDarkMode ? 'rgba(255, 77, 79, 0.8)' : '#FF6B6B';
    }
    return this.isDarkMode ? 'rgba(255, 255, 255, 0.7)' : '#888888';
  }

  private getWaveformColor(): string {
    if (this.showCancelHint) {
      return '#FF4D4F';
    }
    return this.isDarkMode ? '#74B9FF' : '#3498DB';
  }

  private getWaveformMaxHeight(): number {
    const buttonHeight = this.getVoiceHoldButtonHeight();
    const reservedSpace = 32; // é¢„ç•™æ–‡æœ¬åŒºåŸŸé«˜åº¦
    return Math.max(28, buttonHeight - reservedSpace);
  }

  private getWaveformBarHeight(amplitude: number, maxHeight: number): number {
    const minHeight = 6;
    const dynamicHeight = minHeight + amplitude * (maxHeight - minHeight);
    return Math.min(dynamicHeight, maxHeight);
  }

  private handleMicButtonTap(): void {
    if (this.currentInputMode === InputMode.VOICE) {
      return;
    }
    this.switchToVoiceMode();
  }

  private switchToVoiceMode(): void {
    if (this.currentInputMode === InputMode.VOICE) {
      return;
    }
    this.currentInputMode = InputMode.VOICE;
    this.onInputModeChange(InputMode.VOICE);
    void this.triggerHapticFeedback();
  }

  private switchToTextMode(): void {
    if (this.currentInputMode === InputMode.TEXT) {
      return;
    }

    if (this.isGestureRecording || this.recognitionState === VoiceRecognitionState.RECORDING) {
      void this.completeGestureRecording(true);
    }

    if (this.recognitionState === VoiceRecognitionState.PROCESSING) {
      void this.speechService.cancelRecognition();
    }

    if (this.recognitionState !== VoiceRecognitionState.IDLE) {
      this.updateState(VoiceRecognitionState.IDLE);
    }

    this.currentInputMode = InputMode.TEXT;
    this.onInputModeChange(InputMode.TEXT);
    this.showVoiceTips = false;
    this.resetGestureState();
  }

  
  @Builder
  buildMicrophoneIcon() {
    // ç®€æ´çš„éº¦å…‹é£å›¾æ ‡
    Column() {
      // éº¦å…‹é£ä¸»ä½“
      Rect()
        .width(8)
        .height(12)
        .radius(4)
        .fill('transparent')
        .border({ width: 1.5, color: this.getIconColor() })
      
      // æ”¯æ¶å’Œåº•åº§
      Column() {
        Rect()
          .width(1)
          .height(4)
          .fill(this.getIconColor())
        
        Rect()
          .width(8)
          .height(1)
          .fill(this.getIconColor())
      }
      .margin({ top: 1 })
    }
    .opacity(this.recognitionState === VoiceRecognitionState.ERROR ? 0.6 : 1.0)
  }
  
  @Builder
  buildProcessingIcon() {
    // å¤„ç†ä¸­åŠ¨ç”» - ä¸‰ä¸ªå°ç‚¹
    Row() {
      Circle()
        .width(3)
        .height(3)
        .fill(this.getIconColor())
        .opacity(0.4 + this.pulseOpacity * 0.6)
        .animation({
          duration: 600,
          curve: Curve.EaseInOut,
          iterations: -1,
          playMode: PlayMode.Alternate,
          delay: 0
        })
      
      Circle()
        .width(3)
        .height(3)
        .fill(this.getIconColor())
        .margin({ left: 2 })
        .opacity(0.4 + this.pulseOpacity * 0.6)
        .animation({
          duration: 600,
          curve: Curve.EaseInOut,
          iterations: -1,
          playMode: PlayMode.Alternate,
          delay: 200
        })
      
      Circle()
        .width(3)
        .height(3)
        .fill(this.getIconColor())
        .margin({ left: 2 })
        .opacity(0.4 + this.pulseOpacity * 0.6)
        .animation({
          duration: 600,
          curve: Curve.EaseInOut,
          iterations: -1,
          playMode: PlayMode.Alternate,
          delay: 400
        })
    }
  }
  
  
  @Builder
  buildErrorCard() {
    Column() {
      Row() {
        Path()
          .commands('M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z')
          .width(16)
          .height(16)
          .fill('#FF4757')
        
        Text('è¯†åˆ«å¤±è´¥')
          .fontSize(12)
          .fontColor('#FF4757')
          .fontWeight(FontWeight.Medium)
          .margin({ left: 6 })
      }
      .margin({ bottom: 4 })
      
      Text(this.errorText)
        .fontSize(11)
        .fontColor(this.getErrorTextColor())
        .maxLines(2)
        .textAlign(TextAlign.Center)
        .lineHeight(16)
    }
    .padding(12)
    .margin({ top: 8 })
    .backgroundColor(this.getErrorCardBackground())
    .borderRadius(8)
    .border({ width: 1, color: this.getErrorCardBorder() })
    .shadow({
      radius: 4,
      color: this.getErrorCardShadow(),
      offsetX: 0,
      offsetY: 2
    })
  }
  
  /**
   * ä¸»é¢˜å·²é€šè¿‡ThemeManagerç®¡ç†ï¼Œæ­¤æ–¹æ³•ä¿ç•™ç”¨äºå…¼å®¹æ€§
   */
  private detectColorMode(): void {
    // ä¸»é¢˜çŠ¶æ€ç°åœ¨é€šè¿‡ThemeManagerç®¡ç†
    // æ­¤æ–¹æ³•ä¿ç•™ç”¨äºå‘åå…¼å®¹
  }
  
  /**
   * è§¦å‘è§¦è§‰åé¦ˆ
   */
  private async triggerHapticFeedback(): Promise<void> {
    try {
      await vibrator.startVibration({
        type: 'time',
        duration: 50
      }, {
        id: 0,
        usage: 'alarm'
      });
    } catch (error) {
      hilog.warn(0x0000, 'VoiceInputComponent', 'è§¦è§‰åé¦ˆå¤±è´¥: %{public}s', JSON.stringify(error));
    }
  }

  private handleGesturePressDown(event: TouchEvent): void {
    if (this.currentInputMode !== InputMode.VOICE) {
      return;
    }

    this.isPressed = true;
    this.dragDistance = 0;
    this.isSwipeToCancel = false;
    this.isLongPressTriggered = false;
    this.touchStartY = this.getTouchPositionY(event);
    void this.triggerHapticFeedback();
    this.showCancelHint = false;
    this.showVoiceTips = false;
    this.notifyHintUpdate();

    if (this.recognitionState === VoiceRecognitionState.IDLE) {
      this.clearLongPressTimer();
      this.longPressTimer = setTimeout(() => {
        this.isLongPressTriggered = true;
        void this.beginGestureRecording();
      }, this.longPressTriggerMs);
    }
  }

  private handleGestureMove(event: TouchEvent): void {
    if (this.currentInputMode !== InputMode.VOICE) {
      return;
    }

    if (!this.isPressed) {
      return;
    }

    const currentY = this.getTouchPositionY(event);
    if (currentY <= 0) {
      return;
    }

    this.dragDistance = Math.max(0, this.touchStartY - currentY);

    if (!this.isGestureRecording) {
      return;
    }

    const shouldCancel = this.dragDistance >= this.swipeCancelThreshold;
    if (shouldCancel !== this.isSwipeToCancel) {
      this.isSwipeToCancel = shouldCancel;
      void this.triggerHapticFeedback();
    }

    this.showCancelHint = this.isSwipeToCancel;
    this.notifyHintUpdate();
  }

  private handleGestureRelease(forceCancel: boolean): void {
    if (this.currentInputMode !== InputMode.VOICE) {
      return;
    }

    const startedRecording = this.isGestureRecording;
    const shouldCancel = forceCancel || this.isSwipeToCancel;

    this.isPressed = false;
    this.clearLongPressTimer();
    this.showCancelHint = false;
    this.notifyHintUpdate();

    if (!startedRecording) {
      this.resetGestureState();
      return;
    }

    void this.completeGestureRecording(shouldCancel);
  }

  private async beginGestureRecording(): Promise<void> {
    if (this.currentInputMode !== InputMode.VOICE) {
      return;
    }

    if (this.isGestureRecording || this.recognitionState !== VoiceRecognitionState.IDLE) {
      return;
    }

    this.clearLongPressTimer();
    this.isGestureRecording = true;
    this.isSwipeToCancel = false;
    this.dragDistance = 0;
    this.showVoiceTips = false;
    this.isRecording = true;
    this.showCancelHint = false;
    this.notifyHintUpdate();
    if (this.waveAnimationTimer === 0) {
      this.startWaveAnimation();
    }

    await this.triggerHapticFeedback();
    await this.startRealSpeechRecognition();
  }

  private async completeGestureRecording(cancelled: boolean): Promise<void> {
    try {
      if (cancelled) {
        await this.speechService.cancelRecognition();
      } else {
        await this.speechService.stopRecognition();
      }
    } catch (error) {
      Logger.error('VoiceInputComponent', `å®Œæˆè¯­éŸ³æ‰‹åŠ¿æ—¶å¼‚å¸¸: ${JSON.stringify(error)}`);
    } finally {
      this.resetGestureState();
      this.isRecording = false;
      this.stopWaveAnimation();
    }
  }

  private resetGestureState(): void {
    this.isGestureRecording = false;
    this.isSwipeToCancel = false;
    this.isLongPressTriggered = false;
    this.dragDistance = 0;
    this.clearLongPressTimer();
    this.showCancelHint = false;
    this.notifyHintUpdate();
  }

  private getTouchPositionY(event: TouchEvent): number {
    const extendedEvent: ExtendedTouchEvent = event as ExtendedTouchEvent;
    const touch = extendedEvent?.touches?.[0] ?? extendedEvent?.changedTouches?.[0];
    if (!touch) {
      return this.touchStartY;
    }
    return touch.globalY ?? touch.screenY ?? touch.windowY ?? touch.y ?? this.touchStartY;
  }

  private clearLongPressTimer(): void {
    if (this.longPressTimer > 0) {
      clearTimeout(this.longPressTimer);
      this.longPressTimer = 0;
    }
  }

  private notifyHintUpdate(): void {
    const nextHint = this.computeOverlayHint();
    if (this.areHintsEqual(nextHint, this.currentOverlayHint)) {
      return;
    }
    this.currentOverlayHint = nextHint;
    this.onHintChange(nextHint);
  }

  private computeOverlayHint(): VoiceOverlayHint | null {
    if (this.recognitionState === VoiceRecognitionState.PROCESSING) {
      return { text: 'æ­£åœ¨è¯†åˆ«ä¸­...', tone: 'processing' };
    }
    if (this.isGestureRecording) {
      if (this.showCancelHint) {
        return { text: 'æ¾å¼€æ‰‹æŒ‡å–æ¶ˆå‘é€', tone: 'warning' };
      }
      return { text: 'æ¾å¼€æ‰‹æŒ‡å‘é€ï¼Œä¸Šæ»‘å–æ¶ˆ', tone: 'default' };
    }
    return null;
  }

  private areHintsEqual(nextHint: VoiceOverlayHint | null, currentHint: VoiceOverlayHint | null): boolean {
    if (!nextHint && !currentHint) {
      return true;
    }
    if (!nextHint || !currentHint) {
      return false;
    }
    return nextHint.text === currentHint.text && nextHint.tone === currentHint.tone;
  }

  /**
   * çœŸå®è¯­éŸ³è¯†åˆ«
   */
  private async startRealSpeechRecognition(): Promise<void> {
    Logger.info('VoiceInputComponent', 'å¼€å§‹çœŸå®è¯­éŸ³è¯†åˆ«');

    try {
      // å¼€å§‹è¯­éŸ³è¯†åˆ«
      const success = await this.speechService.startRecognition();
      if (!success) {
        Logger.error('VoiceInputComponent', 'å¯åŠ¨è¯­éŸ³è¯†åˆ«å¤±è´¥');
        // ä¸æ˜¾ç¤ºé”™è¯¯ï¼Œç›´æ¥å›åˆ°ç©ºé—²çŠ¶æ€
        this.updateState(VoiceRecognitionState.IDLE);
        return;
      }

      Logger.info('VoiceInputComponent', 'è¯­éŸ³è¯†åˆ«å·²å¯åŠ¨');
    } catch (error) {
      Logger.error('VoiceInputComponent', `è¯­éŸ³è¯†åˆ«å¯åŠ¨å¼‚å¸¸: ${error}`);
      // ä¸æ˜¾ç¤ºé”™è¯¯ï¼Œç›´æ¥å›åˆ°ç©ºé—²çŠ¶æ€
      this.updateState(VoiceRecognitionState.IDLE);
    }
  }
  
  /**
   * æ›´æ–°çŠ¶æ€
   */
  private updateState(state: VoiceRecognitionState): void {
    hilog.info(0x0000, 'VoiceInputComponent', 'æ›´æ–°çŠ¶æ€: %{public}s -> %{public}s', this.recognitionState, state);
    
    this.recognitionState = state;
    this.onStateChange(state);
    
    // æ›´æ–°åŠ¨ç”»çŠ¶æ€
    switch (state) {
      case VoiceRecognitionState.RECORDING:
        this.animationScale = 1.1;
        this.pulseOpacity = 0.8;
        this.startWaveAnimation();
        hilog.info(0x0000, 'VoiceInputComponent', 'å¯åŠ¨å½•éŸ³åŠ¨ç”»');
        this.isGestureRecording = true;
        this.isSwipeToCancel = false;
        this.isLongPressTriggered = false;
        this.dragDistance = 0;
        this.isRecording = true;
        this.showCancelHint = false;
        break;
      case VoiceRecognitionState.PROCESSING:
        this.animationScale = 1.0;
        this.pulseOpacity = 0.3;
        this.startRotationAnimation();
        hilog.info(0x0000, 'VoiceInputComponent', 'å¯åŠ¨å¤„ç†åŠ¨ç”»');
        if (!this.isPressed) {
          this.isGestureRecording = false;
          this.isSwipeToCancel = false;
          this.isLongPressTriggered = false;
          this.dragDistance = 0;
        }
        this.isRecording = false;
        this.showCancelHint = false;
        this.stopWaveAnimation();
        break;
      case VoiceRecognitionState.ERROR:
        // é”™è¯¯çŠ¶æ€ç«‹å³è½¬ä¸ºç©ºé—²çŠ¶æ€ï¼Œä¸æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
        this.animationScale = 0.9; // ç¨å¾®ç¼©å°ä¸€ä¸‹ï¼Œæä¾›è§†è§‰åé¦ˆ
        this.pulseOpacity = 0.3;
        this.rotationAngle = 0;
        hilog.warn(0x0000, 'VoiceInputComponent', 'è¿›å…¥é”™è¯¯çŠ¶æ€ï¼Œè‡ªåŠ¨è½¬ä¸ºç©ºé—²çŠ¶æ€');
        this.resetGestureState();
        this.isRecording = false;
        this.showCancelHint = false;
        this.stopWaveAnimation();
        // çŸ­æš‚å»¶è¿Ÿåè½¬ä¸ºç©ºé—²çŠ¶æ€ï¼Œè®©ç”¨æˆ·èƒ½æ„ŸçŸ¥åˆ°çŠ¶æ€å˜åŒ–
        setTimeout(() => {
          this.animationScale = 1.0; // æ¢å¤æ­£å¸¸å¤§å°
          this.recognitionState = VoiceRecognitionState.IDLE;
          this.notifyHintUpdate();
        }, 300);
        break;
      case VoiceRecognitionState.IDLE:
      default:
        this.animationScale = 1.0;
        this.pulseOpacity = 0.3;
        this.rotationAngle = 0;
        hilog.info(0x0000, 'VoiceInputComponent', 'è¿›å…¥ç©ºé—²çŠ¶æ€');
        this.resetGestureState();
        this.isRecording = false;
        this.showCancelHint = false;
        this.stopWaveAnimation();
        break;
    }
    this.notifyHintUpdate();
  }
  
  /**
   * å¯åŠ¨æ³¢å½¢åŠ¨ç”»
   */
  private startWaveAnimation(): void {
    if (this.waveAnimationTimer !== 0) {
      return;
    }

    this.waveAmplitudes = this.waveAmplitudes.map(() => Math.random() * 0.8 + 0.2);
    this.waveAnimationTimer = setInterval(() => {
      this.waveAmplitudes = this.waveAmplitudes.map(() => Math.random() * 0.8 + 0.2);
    }, 180);
  }
  
  /**
   * å¯åŠ¨æ—‹è½¬åŠ¨ç”»
   */
  private startRotationAnimation(): void {
    this.rotationAngle = 360;
  }

  private stopWaveAnimation(): void {
    if (this.waveAnimationTimer > 0) {
      clearInterval(this.waveAnimationTimer);
      this.waveAnimationTimer = 0;
    }
    this.waveAmplitudes = [...DEFAULT_WAVEFORM];
  }
  
  /**
   * å¤„ç†è¯­éŸ³è¯†åˆ«ç»“æœ
   */
  private async handleVoiceResultInternal(text: string): Promise<void> {
    hilog.info(0x0000, 'VoiceInputComponent', 'å¤„ç†è¯­éŸ³è¯†åˆ«ç»“æœ: %{public}s', text);
    
    // æ£€æµ‹æ˜¯å¦åŒ¹é…è¯­éŸ³è§¦å‘è¯
    await this.checkVoiceTriggerMatch(text);
    
    this.onVoiceResult(text);
  }

  /**
   * æ£€æµ‹è¯­éŸ³è§¦å‘è¯åŒ¹é…
   */
  private async checkVoiceTriggerMatch(recognizedText: string): Promise<void> {
    const lowerText = recognizedText.toLowerCase();
    
    // éå†æ‰€æœ‰promptæ¨¡æ¿ï¼Œæ£€æŸ¥è¯­éŸ³è§¦å‘è¯åŒ¹é…
    for (const template of Constants.PROMPT_TEMPLATES) {
      if (template.voiceTriggers) {
        for (const trigger of template.voiceTriggers) {
          if (lowerText.includes(trigger.toLowerCase())) {
            // è®°å½•è¯­éŸ³è§¦å‘çš„ä½¿ç”¨
            await this.recommendationManager.recordPromptUsage(template.id, true);
            hilog.info(0x0000, 'VoiceInputComponent', `æ£€æµ‹åˆ°è¯­éŸ³è§¦å‘è¯åŒ¹é…: "${trigger}" -> ${template.title}`);
            
            // å¦‚æœè¯†åˆ«æ–‡æœ¬ä¸»è¦æ˜¯è§¦å‘è¯ï¼ˆç›¸ä¼¼åº¦é«˜ï¼‰ï¼Œåˆ™è‡ªåŠ¨åº”ç”¨å¯¹åº”prompt
            if (this.shouldAutoApplyPrompt(recognizedText, trigger)) {
              hilog.info(0x0000, 'VoiceInputComponent', `è‡ªåŠ¨åº”ç”¨æ™ºèƒ½prompt: ${template.prompt}`);
              if (this.onSmartPromptTriggered) {
                this.onSmartPromptTriggered(template.prompt);
              }
            }
            
            return; // åªå¤„ç†ç¬¬ä¸€ä¸ªåŒ¹é…çš„
          }
        }
      }
    }
  }

  /**
   * åˆ¤æ–­æ˜¯å¦åº”è¯¥è‡ªåŠ¨åº”ç”¨promptï¼ˆå½“è¯­éŸ³ä¸»è¦å†…å®¹å°±æ˜¯è§¦å‘è¯æ—¶ï¼‰
   */
  private shouldAutoApplyPrompt(recognizedText: string, trigger: string): boolean {
    const cleanText = recognizedText.toLowerCase().trim();
    const cleanTrigger = trigger.toLowerCase().trim();
    
    // å¦‚æœè¯†åˆ«æ–‡æœ¬å°±æ˜¯è§¦å‘è¯æˆ–è€…åŒ…å«è§¦å‘è¯ä¸”æ–‡æœ¬è¾ƒçŸ­ï¼Œåˆ™è‡ªåŠ¨åº”ç”¨
    return cleanText === cleanTrigger || 
           (cleanText.includes(cleanTrigger) && cleanText.length <= cleanTrigger.length + 5);
  }
  
  /**
   * è·å–æŒ‰é’®èƒŒæ™¯é¢œè‰² - ä¸å‘é€æŒ‰é’®é£æ ¼ä¸€è‡´
   */
  private getButtonBackgroundColor(): string {
    switch (this.recognitionState) {
      case VoiceRecognitionState.PROCESSING:
        return '#74B9FF';  // å¤„ç†çŠ¶æ€ä½¿ç”¨è“è‰²
      case VoiceRecognitionState.ERROR:
        return '#FF7675';  // é”™è¯¯çŠ¶æ€ä½¿ç”¨æ·¡çº¢è‰²
      default:
        return '#74B9FF';  // é»˜è®¤çŠ¶æ€ä½¿ç”¨è“è‰²ï¼Œä¸ä¸»é¢˜è‰²ä¸€è‡´
    }
  }
  
  
  
  /**
   * è·å–çŠ¶æ€æŒ‡ç¤ºå™¨é¢œè‰²
   */
  /**
   * è·å–å›¾æ ‡é¢œè‰²
   */
  private getIconColor(): string {
    switch (this.recognitionState) {
      case VoiceRecognitionState.RECORDING:
        return '#FFFFFF';
      case VoiceRecognitionState.PROCESSING:
        return '#FFFFFF';
      case VoiceRecognitionState.ERROR:
        return '#FFFFFF';
      default:
        return '#FFFFFF';
    }
  }
  
  /**
   * è·å–æŒ‰é’®å®½åº¦ - ä¸å‘é€æŒ‰é’®ä¿æŒä¸€è‡´
   */
  private getButtonWidth(): number {
    return 40;
  }
  
  /**
   * è·å–æŒ‰é’®é«˜åº¦ - ä¸å‘é€æŒ‰é’®ä¿æŒä¸€è‡´
   */
  private getButtonHeight(): number {
    return 40;
  }
  
  /**
   * è·å–æŒ‰é’®åœ†è§’ - ä¸å‘é€æŒ‰é’®ä¿æŒä¸€è‡´
   */
  private getButtonRadius(): number {
    return 20;
  }
  
  /**
   * å“åº”å¼è®¾è®¡ - è·å–å›¾æ ‡å°ºå¯¸
   */
  private getIconSize(): number {
    return 24;
  }

  /**
   * æš—è‰²ä¸»é¢˜ - è·å–é”™è¯¯å¡ç‰‡èƒŒæ™¯
   */
  private getErrorCardBackground(): string {
    return this.isDarkMode ? 'rgba(139, 69, 19, 0.2)' : '#FFF5F5';
  }
  
  /**
   * æš—è‰²ä¸»é¢˜ - è·å–é”™è¯¯å¡ç‰‡è¾¹æ¡†
   */
  private getErrorCardBorder(): string {
    return this.isDarkMode ? 'rgba(255, 71, 87, 0.4)' : 'rgba(255, 71, 87, 0.2)';
  }
  
  /**
   * æš—è‰²ä¸»é¢˜ - è·å–é”™è¯¯å¡ç‰‡é˜´å½±
   */
  private getErrorCardShadow(): string {
    return this.isDarkMode ? 'rgba(255, 71, 87, 0.2)' : 'rgba(255, 71, 87, 0.1)';
  }
  
  /**
   * æš—è‰²ä¸»é¢˜ - è·å–é”™è¯¯æ–‡æœ¬é¢œè‰²
   */
  private getErrorTextColor(): string {
    return this.isDarkMode ? '#CCCCCC' : '#666666';
  }

  @Builder
  buildVoiceTipCard() {
    Column({ space: 4 }) {
      Row() {
        Text('ğŸ’¡')
          .fontSize(14)
        
        Text('è¯­éŸ³æç¤º')
          .fontSize(12)
          .fontColor('#74B9FF')
          .fontWeight(FontWeight.Medium)
          .margin({ left: 4 })
      }
      
      Text(`è¯•è¯•è¯´: "${this.voiceTipText}"`)
        .fontSize(11)
        .fontColor(this.getTipTextColor())
        .textAlign(TextAlign.Center)
        .lineHeight(16)
        .maxLines(2)
        .textOverflow({ overflow: TextOverflow.Ellipsis })
        .margin({ top: 2 })
    }
    .padding({ left: 12, right: 12, top: 8, bottom: 8 })
    .margin({ top: 8 })
    .backgroundColor(this.getTipCardBackground())
    .borderRadius(12)
    .border({ width: 1, color: this.getTipCardBorder() })
    .shadow({
      radius: 4,
      color: this.getTipCardShadow(),
      offsetX: 0,
      offsetY: 2
    })
    .opacity(0.9)
    .animation({
      duration: 300,
      curve: Curve.EaseInOut
    })
    .onClick(() => {
      // ç‚¹å‡»æç¤ºå¡ç‰‡æ—¶éšè—æç¤º
      this.showVoiceTips = false;
    })
  }

  /**
   * å¯åŠ¨è¯­éŸ³æç¤ºè½®æ¢
   */
  private startVoiceTipRotation(): void {
    // ç«‹å³æ˜¾ç¤ºç¬¬ä¸€ä¸ªæç¤º
    this.updateVoiceTip();
    
    // è®¾ç½®å®šæœŸè½®æ¢
    this.tipRotationTimer = setInterval(() => {
      if (this.recognitionState === VoiceRecognitionState.IDLE && !this.showVoiceTips) {
        this.updateVoiceTip();
      }
    }, 5000); // æ¯5ç§’è½®æ¢ä¸€æ¬¡
  }

  /**
   * æ›´æ–°è¯­éŸ³æç¤ºæ–‡æœ¬
   */
  private updateVoiceTip(): void {
    const allTriggers: string[] = [];
    
    // æ”¶é›†æ‰€æœ‰è¯­éŸ³è§¦å‘è¯
    Constants.PROMPT_TEMPLATES.forEach(template => {
      if (template.voiceTriggers) {
        allTriggers.push(...template.voiceTriggers);
      }
    });
    
    if (allTriggers.length > 0) {
      // å¾ªç¯é€‰æ‹©ä¸åŒçš„è§¦å‘è¯
      this.voiceTipText = allTriggers[this.tipRotationIndex % allTriggers.length];
      this.tipRotationIndex++;
    }
  }

  /**
   * è·å–æç¤ºå¡ç‰‡èƒŒæ™¯è‰²
   */
  private getTipCardBackground(): string {
    return this.isDarkMode ? 'rgba(0, 0, 0, 0.8)' : 'rgba(255, 255, 255, 0.95)';
  }

  /**
   * è·å–æç¤ºå¡ç‰‡è¾¹æ¡†è‰²
   */
  private getTipCardBorder(): string {
    return this.isDarkMode ? 'rgba(116, 185, 255, 0.3)' : 'rgba(116, 185, 255, 0.2)';
  }

  /**
   * è·å–æç¤ºå¡ç‰‡é˜´å½±
   */
  private getTipCardShadow(): string {
    return this.isDarkMode ? 'rgba(116, 185, 255, 0.2)' : 'rgba(116, 185, 255, 0.1)';
  }

  /**
   * è·å–æç¤ºæ–‡æœ¬é¢œè‰²
   */
  private getTipTextColor(): string {
    return this.isDarkMode ? '#CCCCCC' : '#666666';
  }
}
